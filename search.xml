<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FLash</title>
    <url>/2023/03/29/FLash-0/</url>
    <content><![CDATA[<h2 id="Flash-解决更新风暴、长尾到达的最新数据平面验证-学习1">Flash-解决更新风暴、长尾到达的最新数据平面验证-学习1</h2>
<span id="more"></span>
<h3 id="预先知识">预先知识</h3>
<h4 id="首先介绍一下更新风暴的概念与示例">首先介绍一下更新风暴的概念与示例</h4>
<blockquote>
<p>更新风暴：短时间内发生大量数据平面更新</p>
<p>长尾到达：有些交换机的更新需要很长时间到达</p>
</blockquote>
<h4 id="更新风暴示例">更新风暴示例</h4>
<img src="/2023/03/29/FLash-0/img_2.png" class title="img_2.png">
<img src="/2023/03/29/FLash-0/img_3.png" class title="img_3.png">
<blockquote>
<p>在之前的研究工作中，互联网中单个故障可能出发BGP撤销，从而导致域内网络FIB变化</p>
</blockquote>
<blockquote>
<p>如上图所述，考虑图a中的网络，假设它从AS-1和AS-2接收10K前缀，10K前缀的最佳路径是通过边界路由器A</p>
<p>如图b所示。在A与Internet链路断开后，前缀从AS-1中撤回，新的最佳路径是通过路由器B转发数据包</p>
<p>如图b所示。对于3节点拓扑，更改将触发30K FIB更新。域内的链路改变也可能触发大量的FIB更新</p>
<p>考虑图c中的网络，当从C到B建立新的链路时，最佳域内路径从C-A-B更改为C-B。因此，它将触发所选前缀的10K更新。</p>
<p>作者使用FRR评估了第一个图的场景，第二个图显示了当我们触发链接事件时更新的累积分布。</p>
<p>当链接A-Internet失败时，我们在0.48秒内收到来自A的10K突发更新，而在链接B-C建立后1.36秒内，我们在0.58秒内收到C的10K突发更新.</p>
<p>将这些条目馈送到数据平面验证器会导致长的验证时间和大的内存消耗，即使对于增量数据平面验证器来说，大量的更新也可能具有挑战性。</p>
<p>虽然可以采用分而治之的方法，但成本取决于分区方法和数据平面的复杂性，并且仍然可能非常大</p>
</blockquote>
<h4 id="首先介绍什么是Fat树">首先介绍什么是Fat树</h4>
<h5 id="Fat-Tree特点">Fat-Tree特点</h5>
<blockquote>
<p>是以交换机为中心的拓扑</p>
<p>支持在横向拓展的同时拓展路径数目</p>
<p>且所有交换机均为相同端口数量的普通设备，降低了网络建设成本</p>
</blockquote>
<p>Fat-Tree结构共分为三层：核心层、汇聚层、接入层。</p>
<p>一个k元的Fat-Tree可以归纳为6个特征：</p>
<blockquote>
<p>每台交换机都有k个端口</p>
<p>核心层为顶层，一共有(k/2)^2个交换机</p>
<p>一共有k个pod，每个pod有k台交换机组成。其中汇聚层和接入层各占k/2台交换机</p>
<p>接入层每个交换机可以容纳k/2台服务器</p>
<p>k元Fat-Tree一共有k个pod，每个pod容纳k×k/4个服务器，所有pod共能容纳k×k×k/4台服务器；</p>
<p>任意两个pod之间存在k条路径</p>
</blockquote>
<p>下图是k=4的胖树结构</p>
<img src="/2023/03/29/FLash-0/img.png" class title="img.png">
<p>考虑下图中所示的场景，假设网络具有K-ary胖树拓扑结构，每个POD都有P个前缀。什么时候K=32和P=32，其中有1310720个FIB规则和71680个FIB改变是在向数据中心网络添加新的pod时通过BGP模拟生成的。下图中四个参数分别代表：胖树参数、每个pod的前缀、修改后规则总数、修改的规则数</p>
<img src="/2023/03/29/FLash-0/img_1.png" class title="img_1.png">
<blockquote>
<p>我们可以看到，在经过网络故障后，会产生大量的FIB更新</p>
</blockquote>
]]></content>
      <tags>
        <tag>FLash</tag>
      </tags>
  </entry>
  <entry>
    <title>FLash-1</title>
    <url>/2023/03/29/FLash-1/</url>
    <content><![CDATA[<h2 id="Flash-解决更新风暴、长尾到达的最新数据平面验证-学习2">Flash-解决更新风暴、长尾到达的最新数据平面验证-学习2</h2>
<span id="more"></span>
<h3 id="一种声明性需求规范语言">一种声明性需求规范语言</h3>
<img src="/2023/03/29/FLash-1/img.png" class title="FLash-1&#x2F;img.png">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;packet_space, sources, path_set&gt;的含义</span><br><span class="line">所有数据包来自packet_space，都可以从sources中设备进入网络，并必须沿着属于指定为正则表达式的path_set的至少一个路径转发</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">&lt;sip = 10.0.1.0/24 and dip = 10.0.2.0/24,[S],S.W.*＞$&gt;的含义</span><br><span class="line">对于在设备S处进入网络的源IP在10.0.0.0/24中且目标IP在10.0.2.0/24中的任何数据包，能够到达至少一个具有可到达数据包目的地的外部端口的设备，同时指向设备W</span><br></pre></td></tr></table></figure>
<h3 id="IMT的形式化理论">IMT的形式化理论</h3>
<h4 id="基本概念">基本概念</h4>
<h5 id="计算有效断言">计算有效断言</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设第1个设备只有两条规则p1和p2 </span><br><span class="line">p1=(dstip=10.0.0.0/24 pri=2 forward port1)</span><br><span class="line">p2=(dstip=10.0.0.0/16 pri=1 forward port2)</span><br><span class="line">显然 p1的优先级更高 因此p1的有效断言=transfor(10.0.0.0/24)</span><br><span class="line">但是p2的有效断言显然不是 p2的优先断言=transfor(p1∩(否定)p2)</span><br><span class="line">即p2的实际部分应该是10.0.1.0——10.0.255.255 即不包含p1 可以使用下面公式表示</span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/1.png" class title="Flash-1&#x2F;1.png">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何进行模型转换R(基于规则的)-&gt;M(基于等价类的)，公式如下</span><br><span class="line">公式的含义就是所有规则的有效断言的union 通过这个公式就完成断言的转换</span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/2.png" class title="FLash-1&#x2F;2.png">
<h5 id="规则更新（插入或删除）">规则更新（插入或删除）</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规则更新无非有两种：插入规则与删除规则</span><br><span class="line">插入规则：设备原始规则（优先级比新规则低）有效断言减少</span><br><span class="line">删除规则：设备原始规则（优先级比新规则低）有效断言增加</span><br></pre></td></tr></table></figure>
<h5 id="规则逐条更新效率很低">规则逐条更新效率很低</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因：假设存在两条规则集r1，r2，规则集中分别包含2，3条</span><br><span class="line">r1规则集：</span><br><span class="line">r11=(dstip=10.0.0.0/24 pri=2 forward port1)</span><br><span class="line">r12=(dstip=10.1.0.0/24 pri=2 forward port1)</span><br><span class="line">r2规则集：</span><br><span class="line">r21=(dstip=10.0.0.0/16 pri=1 forward port2)</span><br><span class="line">r22=(dstip=10.1.0.0/16 pri=1 forward port2)</span><br><span class="line">r22=(dstip=10.2.0.0/16 pri=1 forward port2)</span><br><span class="line">首先计算r1的有效断言</span><br><span class="line">eff_r1 = eff_r11 ∪ eff_r12</span><br><span class="line">再计算r2的有效断言</span><br><span class="line">eff_r2 = (eff_r21 ∪ eff_r22 ∪ eff_r23) ∩ (否定)(eff_r11 ∪ eff_r12)</span><br><span class="line">我们可以注意到 eff_r11 ∪ eff_r12 已经在计算eff_r1时计算过了，如果单独更新规则集r2，则会产生冗余</span><br><span class="line"></span><br><span class="line">问：作者是如何解决这个问题的？</span><br><span class="line">答：检查两个断言是否可以合并，若插入的断言p1和断言p2有相同的动作(转发到port1)，则可以创建新的断言</span><br><span class="line">p=p1∪p2，这样再计算有效断言时可以减小冗余，缩短时间</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:数据包头部</span><br><span class="line">output:转发行为</span><br><span class="line">注意：IMT不处理具体某个input，而是处理input集合</span><br></pre></td></tr></table></figure>
<h5 id="覆盖允许更新组合的运算符">覆盖允许更新组合的运算符</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新的更新（S3-S2-S1）到来后，首先发生在设备S3，即下图中ΔR3</span><br><span class="line">由于存在两条规则，因此有两次更新</span><br><span class="line">更新1：ΔR3中第一行，重写运算符就是(Δp=p4,Δy)，其中Δy指定了采取的动作，从S3到S2，写作y3=S2；</span><br><span class="line">然后将该断言与原本断言就行交集运算，判断，有以下两种情况：</span><br><span class="line">&lt;1&gt;为空，该重写运算符不起作用</span><br><span class="line">&lt;2&gt;不为空，相交的部分成为新的等价类，其余部分不变（类似于APKeep中分离断言）</span><br><span class="line">更新2：ΔR3中第二行，重写运算符就是(Δp=p5,Δy)</span><br><span class="line"></span><br><span class="line">reduce1:键是Δy，对于具有相同键(Δy)的断言，断言(Δp)被减少</span><br><span class="line">reduce2:键是Δp，对于具有相同键(Δp)的断言，断言(Δy)被减少</span><br><span class="line">这两步都能提高效率</span><br><span class="line"></span><br><span class="line">如下图所示</span><br><span class="line">在S3处reduce1 就是将p4与p5合并，即p3=p4∨p5</span><br><span class="line">reduce2 就是将ΔM1、ΔM2、ΔM3进行Δy合并，即Δy=&#123;y3=S2,y2=S1,y1=A&#125;,即&#123;A,S1,S2&#125;</span><br><span class="line"></span><br><span class="line">注意：map-reduce过程仅适用于无冲突覆盖。</span><br><span class="line">冲突覆盖的概念：</span><br><span class="line">两个覆盖运算符(Δp,Δy)和(Δp′,Δy′)存在冲突，当且仅当Δp和Δp′相交，并且它们在同一设备上写入不同的动作。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/3.png" class title="FLash-1&#x2F;3.png">
<h4 id="应用">应用</h4>
<h5 id="高效计算ΔM">高效计算ΔM</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下算法是规则更新后，根据ΔR计算ΔM的算法</span><br><span class="line">输入：ΔRi:第i个设备的本地更新块 Ri:更新前已排序的初始规则</span><br><span class="line">输出：ΔMi:等价于ΔRi的原子重写集合 Ri&#x27;:更新后已排序的最终规则</span><br><span class="line">步骤</span><br><span class="line">L1:移除ΔRi中无用的更新 （先增加后删除 或 先删除后增加）</span><br><span class="line">L2:排序ΔRi按优先级降序排列</span><br><span class="line">L3:Rdiff为MergeBlockAndDiff(Ri,ΔRi)的结果</span><br><span class="line">L4:Ri&#x27;=Ri 将更新赋值于Ri&#x27;</span><br><span class="line">L5:ΔMi为CalculateAtomicOverwrite(Ri&#x27;,Rdiff)的结果</span><br><span class="line">L6:返回Ri&#x27;，ΔMi</span><br><span class="line">具体函数含义</span><br><span class="line">函数：MergeBlockAndDiff(Ri,ΔRi) 合并本地更新</span><br><span class="line">    L8-L11:初始化</span><br><span class="line">L8:Rdiff初始化为空列表</span><br><span class="line">L9:优先级较高的规则是否被删除higher初始化为false</span><br><span class="line">L10:r初始化为Ri的最高优先级</span><br><span class="line">L11:δ=(op,rδ)是ΔRi中最高优先级的更新</span><br><span class="line">    L12-L16:首先定位应该应用更新的位置。</span><br><span class="line">L12:首先判断δ是否为空，不为空（表示存在更新）</span><br><span class="line">L13:判断ΔRi中最高优先级的规则rδ是在r之后增加/删除的，如果是</span><br><span class="line">L14:判断优先级较高的规则是否被删除higher是否为true，如果是</span><br><span class="line">L15:扩展Rdiff，即Rdiff.add(r)</span><br><span class="line">L16:遍历Ri的下一条规则，并赋值于r</span><br><span class="line">    L17-L20:插入更新</span><br><span class="line">L17:如果ΔRi中最高优先级的规则rδ不是在r之后增加/删除的</span><br><span class="line">L18:如果最高优先级的动作是插入</span><br><span class="line">L19:在规则r前增加rδ</span><br><span class="line">L20:扩展Rdiff，即Rdiff.add(r)</span><br><span class="line">    L21-L24:删除更新</span><br><span class="line">L21:如果最高优先级的动作是删除</span><br><span class="line">L22:从Ri中删除r</span><br><span class="line">L23:优先级较高的规则是否被删除higher为true</span><br><span class="line">L24:遍历Ri的下一条规则，并赋值于r</span><br><span class="line">L25:获取ΔRi中下一个更新δ</span><br><span class="line">L26:若δ为空，判断优先级较高的规则是否被删除higher是否为true，如果是</span><br><span class="line">L27:将Ri中剩余规则添加到Rdiff</span><br><span class="line">L28:返回Rdiff</span><br><span class="line"></span><br><span class="line">该算法主要是计算ΔM 即reduce1，该算法并没有实现断言的合并</span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/4.png" class title="FLash-1&#x2F;4.png">
<h5 id="快速IMT">快速IMT</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入空间分区:快速IMT的复杂性取决于反向模型和更新的大小，这两者都与数据平面中的规则数量有关。通过将空间划分为多个子空间，可以减少更新过程中有效对的数量，以及受影响规则的数量。因此，它可以大大提高模型更新的速度。</span><br><span class="line">快速查找重叠规则:计算原子重写(ΔMi)是计算每个受影响规则的有效断言。可以看出，规则的有效断言r将影响或受其他规则影响r&#x27;，只有当它们的匹配重叠时。mr∧mr&#x27;≠∅. 在一些常见的场景中，例如，当数据平面主要由最长前缀匹配规则组成时，重叠规则的数量通常远小于设备上的规则数量。为了加快原子覆盖的计算，Flash使用多维前缀Trie[24]来实现对重叠规则的快速查找。</span><br><span class="line">PAT:</span><br></pre></td></tr></table></figure>
<h4 id="早期检查">早期检查</h4>
<h5 id="目前数据平面验证工具存在的问题">目前数据平面验证工具存在的问题</h5>
<blockquote>
<p>问题</p>
<p>&lt;1&gt;如何调度规则更新来构建与收敛状态一致的模型？</p>
<p>&lt;2&gt;如何在信息不完整的情况下有效地计算验证结果？</p>
</blockquote>
<h5 id="Flash是如何做的">Flash是如何做的</h5>
<blockquote>
<p>&lt;1&gt;识别一致的FIB更新，即从相同的网络状态计算的更新</p>
<p>&lt;2&gt;识别潜在的收敛状态</p>
<p>&lt;3&gt;将潜在收敛状态（为了效率）的一致FIB更新（为了正确性）调度到同一验证器</p>
</blockquote>
<h5 id="识别与Epoch一致的FIB更新">识别与Epoch一致的FIB更新</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flash使用网络状态来表示路由软件用来计算转发规则（例如，链路状态和前缀配置）的信息。</span><br><span class="line">随着网络的发展，其状态也会因不同事件（如链路故障）而发生变化。在同步状态协议中，状态更改会传播到整个网络。</span><br><span class="line"></span><br><span class="line">Flash通过将不同网络状态计算的规则更新划分为epochs来区分这些更新。</span><br><span class="line">具体来说，每个epoch表示全局网络状态的快照。</span><br><span class="line">由于仅通过查看数据平面无法确定更新是否来自同一网络状态，Flash使用代理增强了路由软件。</span><br><span class="line">代理计算标签(OpenR实现中，Flash使用密钥的哈希值和状态变量的版本作为epoch标签)，即epoch的唯一标识符，并将标签与根据状态计算的FIB更新相关联。</span><br><span class="line">Flash要求代理和调度器之间的消息传递是串行的，即，来自同一设备的更新总是以与生成更新相同的顺序接收。</span><br><span class="line">然而，Flash对来自不同设备上的代理的消息没有任何限制。</span><br><span class="line"></span><br><span class="line">通过Epoch依赖性跟踪识别潜在的聚合状态。</span><br><span class="line">由于Flash需要设备和调度器之间的严格顺序，如果调度器在接收到具有t2的更新之前在设备i上接收到具有t1的更新，则t1不能是收敛状态。</span><br><span class="line">类似地，如果我们在t3之前看到t2，即使t2是设备i上的最新标签，我们也可以推断t2不可能是收敛状态。这被称为分布式系统中的“先发生后发生”关系，表示为t1≺t2。</span><br><span class="line">Flash维护每个设备的最新标签和一组没有后续epoch的“活动”epoch。</span><br><span class="line">一旦从设备i接收到新标签tnew（其旧标签为ti＝told），Flash就从活动集中删除told，并用tnew替换tell。</span><br><span class="line">如果tnew没有被标记为非活动（由另一个设备），Flash会将tnew添加到活动集。标记在活动集中的epoch是一个潜在的收敛状态。</span><br><span class="line"></span><br><span class="line">调度一致的FIB更新</span><br><span class="line">由于更新与epoch标签相关联，Flash维护了从epoch标签到验证器的映射。</span><br><span class="line">具体地，在从设备接收到具有新epoch标记t的更新时，</span><br><span class="line">Flash首先将更新附加到设备的更新队列，并检查t是否在活动集中。</span><br><span class="line">如果t不在活动集中，这意味着同一设备将来会有更新，则不需要进一步操作。</span><br><span class="line">否则，如果t在活动集中，Flash会找到（或创建一个，如果不存在）t的验证器，并将更新从设备的更新队列馈送到该验证器。</span><br><span class="line">在实践中，Flash可能需要采用退避机制，以避免由于控制平面错误或对不稳定链路的不当处理而快速创建验证器。</span><br><span class="line"></span><br><span class="line">一个示例更新设置如图3所示。考虑由两个链路故障触发的更新:(S,W)和(B,Y)。</span><br><span class="line">假设每个设备的初始标签为t0＝[0，0，…]，其中第一个/第二个元素是链路(S,W)/(B,Y)的描述。</span><br><span class="line">假设在时间T1，Flash接收来自具有标签t1＝[1，0，…]的S的更新（在看到(S,W)的故障之后），以及来自具有标签t2＝[0，1，…]（在发现(B,Y)的故障后）的交换机A和B的更新。</span><br><span class="line">在T1，t1和t2是潜在的收敛状态，并且被置于不同的验证器中。</span><br><span class="line">然而，如果在时间T2&gt;T1时，Flash从交换机S、A和B接收到更新，并且epoch标记t3=[1、1、…]，则调度程序将把T1和T2标记为非活动，并为t3创建一个新的验证器，因为t3现在处于活动状态。</span><br><span class="line">然后，如果Flash从交换机E接收到标记为t2的更新，则Flash只需将更新附加到E的队列中，而不将其发送给任何验证器。</span><br><span class="line">当它从E接收到具有t3的更新时，它将更新刷新到与标签t3相关联的验证器。</span><br><span class="line">图4（a）显示了为每个epoch构建的模型，并在底部显示了不一致状态的示例。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/5.png" class title="FLash-1&#x2F;5.png">
<img src="/2023/03/29/FLash-1/6.png" class title="FLash-1&#x2F;6.png">
<h5 id="通用正则表达式需求的一致性早期检查">通用正则表达式需求的一致性早期检查</h5>
<blockquote>
<p>作者首先指定了Flash如何对正则表达式中指定的一般要求执行一致的早期检测</p>
<p>图16给出了Flash中需求规范语言的简化语法</p>
</blockquote>
<img src="/2023/03/29/FLash-1/7.png" class title="FLash-1&#x2F;7.png">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证图和一致部分验证</span><br><span class="line">Flash计算验证图，作为网络自动机和需求表达自动机的叉积自动机Gp，用于每个数据包空间H和一组源src。</span><br><span class="line">初始验证图包含G中的所有路径，这些路径</span><br><span class="line">（1）从srcs开始</span><br><span class="line">（2）匹配所有正则表达式</span><br><span class="line">考虑图3中的网络和需求。要求是子空间中的数据包ℎ在S处进入的数据包必须沿着穿过W和Y之一的简单路径到达D。</span><br><span class="line">图4(b)显示了初始状态S1和接受状态D1的验证图。</span><br><span class="line">有了这个图，对需求表达式的验证就相当于在验证图中找到一条可以达到接受状态的路径。</span><br><span class="line">具体地说，如果存在这样一个仅由同步节点组成的路径，则该需求始终得到满足。</span><br><span class="line">如果存在一条仅由同步节点组成的路径，则拒绝状态将始终不满足要求。否则，验证结果未知。</span><br><span class="line"></span><br><span class="line">递减更新和可达性查询。</span><br><span class="line">随着越来越多的节点变得同步，该epoch网络中可能符合需求的路径集正在单调减少。</span><br><span class="line">考虑图3中的示例，在接收到图4（b）中的Update1之后，验证图只包含绿色区域中的节点和边。</span><br><span class="line">在进一步接收更新2之后，Gp中没有有效的路径，这意味着无论如何，都无法满足图3中的要求ℎ 由其他设备转发。</span><br><span class="line">在这种递减图中的可达性查询（即，边总是被移除，但从不添加）具有恒定的时间复杂性[41]。该算法的细节和伪代码，以及如何将其扩展为对更复杂的流量模式（例如，任意播、多播和覆盖要求[27]）执行早期检测，见附录D.2。</span><br></pre></td></tr></table></figure>
<h5 id="一致早期循环检测技术">一致早期循环检测技术</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来讲有两种方式</span><br><span class="line">1.删除非同步节点，判断同步节点间是否存在循环 -&gt; 缺点：容易错过早期检测机会</span><br><span class="line">2.保持非同步节点，假设非同步节点的所有下一跳是任意一个接口，系统枚举所有可能，计算是否存在循环 -&gt; 缺点：计算代价高</span><br><span class="line"></span><br><span class="line">Flash结合这两种方法 提出hyper node compression方法</span><br><span class="line">hyper node compression：</span><br><span class="line">未同步节点的每个连接组件都被压缩为超节点，以降低枚举成本。</span><br><span class="line">设U表示非同步节点的连通分量，该连通分量由超节点w代替。对于每个(u,v)∈E，u∉U和v∈U，移除(u,v)并向E添加边(u,w)。</span><br><span class="line">用超节点验证此图将给出与第二种方法相同的结果，但避免枚举U中的路径。</span><br><span class="line"></span><br><span class="line">请考虑图5中的示例。在图5(a)中，当sync=&#123;A,B&#125;时，我们可以将未同步的节点C和X合并为一个超节点，表示为C&amp;X。</span><br><span class="line">在这种情况下，</span><br><span class="line">可能存在一个循环，例如B→A→C&amp;X→B，是原始图中B→A→X→B，</span><br><span class="line">或者是无循环，例如B→A→C&amp;X→out，是原始图中是B→A→X→C→out，</span><br><span class="line">因此最终结果尚未确定。</span><br><span class="line">然而，如果C是同步的，如图5(b)所示，Flash报告说，只要X不丢弃数据包，就会在最终状态下出现循环。如果只验证同步节点，则无法检测到这一点。</span><br><span class="line"></span><br><span class="line">增量检测</span><br><span class="line">Flash不检测来自所有可能节点的循环，而是只检测包含刚刚同步的节点的循环。</span><br><span class="line">设VS和V&#x27;S相应地表示同步节点的旧集合和新集合。</span><br><span class="line">如果在旧图中未检测到循环，则新图中的新循环必须包含V&#x27;S\VS中的节点。</span><br><span class="line">结合超节点压缩(hyper node compression)和增量检测，Flash增量检查新的同步节点。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/29/FLash-1/figure5.png" class title="FLash-1&#x2F;figure5.png">
<p>定义1：(input space,predicate,selection)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L:表示input的位数</span><br><span class="line">input space:所有可能input值的集合 X=&#123;0,1&#125;^L</span><br><span class="line">predicate:布尔函数p:X-&gt;&#123;0,1&#125;</span><br><span class="line">selection:&#123;x∈X|p(x)=1&#125;</span><br><span class="line">P:X上的断言空间 </span><br><span class="line">p0：对于x∈X，都能表示满足p0(x)=0的断言</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>FLash</tag>
      </tags>
  </entry>
  <entry>
    <title>FLash-2</title>
    <url>/2023/03/30/FLash-2/</url>
    <content><![CDATA[<h2 id="Flash-解决更新风暴、长尾到达的最新数据平面验证-学习3">Flash-解决更新风暴、长尾到达的最新数据平面验证-学习3</h2>
<span id="more"></span>
<h3 id="本次是Flash实验评估">本次是Flash实验评估</h3>
<h4 id="评估">评估</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回答四个关键问题</span><br><span class="line">（1）在具有大量更新的真实世界大型网络中，Flash的性能如何？Flash在不同设置下的性能有多强？（§5.2）</span><br><span class="line">（2）根据真实路由的FIB更新的到达模式，Flash的性能如何？（§5.3）</span><br><span class="line">（3）每种优化技术如何有助于整体性能的提高？（§5.4）</span><br><span class="line">（4）就计算需求而言，Flash的开销（成本）是多少？(§5.5)</span><br></pre></td></tr></table></figure>
<h4 id="实验设置">实验设置</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快速IMT命名方式：A-B，其中A代表网络拓扑，B代表FIB生成</span><br><span class="line">示例：LNet-apsp</span><br><span class="line">&lt;1&gt;该设置使用LNet拓扑，这是一种基于Fabric网络架构的专有网络</span><br><span class="line">&lt;2&gt;FIB规则是通过运行全对最短路径算法生成的。</span><br><span class="line">CE2D命名方式：A-B-C[-D]，其中A表示网络拓扑，B表示FIB生成，C表示要验证的属性（所有对可达性和环路自由度），可选的D（如果存在）表示存在长尾到达。</span><br><span class="line">示例：I2-OpenR/1buggy-loop-lt</span><br><span class="line">&lt;1&gt;使用Internet2拓扑</span><br><span class="line">&lt;2&gt;FIB规则是由真正的OpenR软件生成的，除了一个交换机，它正在运行一个有缺陷的OpenR实例</span><br><span class="line">&lt;3&gt;所述验证器被配置为检查所述循环自由度要求</span><br><span class="line">&lt;4&gt;存在长尾到达</span><br><span class="line">所有的设置如下图（包含数据集信息）</span><br><span class="line"></span><br><span class="line">实验环境设置</span><br><span class="line">8个vCPU(2.5GHz)和32GB内存的Ubuntu云服务器上进行的。</span><br><span class="line">操作系统是Ubuntu（x64）18.04。</span><br><span class="line">安装了OpenJDK v17.0.3的LTS</span><br><span class="line"></span><br><span class="line">代码配置(已开源)</span><br><span class="line">https://github.com/snlab/flash </span><br><span class="line">大约4000行java代码</span><br><span class="line"></span><br><span class="line">Flash设备代理实现</span><br><span class="line">设备代理（如果需要一致的早期检测功能）可以通过修补现实世界生产网络中采用的开源模块化路由平台来实现。特别是，在评估中以开源路由软件OpenR[33]为平台。</span><br><span class="line">OpenR：https://github.com/facebook/openr</span><br><span class="line">OpenR是一种状态同步协议，它将其状态变量（即Adj、Prefix）存储在K-V存储中，并使用决策和Fib模块计算路由。</span><br><span class="line">扩展有大约150行C++代码。通过扩展，从相同的网络状态计算的规则更新被封装到带有标签的Thrift[46]消息中，并被发送到验证系统。</span><br><span class="line"></span><br><span class="line">Flash也实现了Delta-net、APKeep、APKeep*进行实验对比</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/table2.png" class title="Flash-2&#x2F;table2.png">
<h4 id="评估基准">评估基准</h4>
<h5 id="评估1：在大规模网络-LNet-ecmp和LNet-smr-中评估">评估1：在大规模网络(LNet-ecmp和LNet-smr)中评估</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者通过将所有交换机的规则插入放在一个序列中来生成更新，将更新序列提供给验证器，并测量执行时间和内存消耗来构建反向模型。如果执行时间超过10小时，我们将终止JVM。</span><br><span class="line">实验结果图：如下图6所示</span><br><span class="line">我们很容易看到：</span><br><span class="line">LNet-ecmp和LNet-smr的Flash(绿色)分别在19秒和4秒内完成，而Delta-net*(蓝色)和APKeep*(橙色)都无法在10小时内完成。</span><br><span class="line">因此，对于LNet-smr，Flash的性能优于Delta-net*和APKeep*9000倍（10小时除以4秒）。</span><br><span class="line">Flash（绿色）的内存消耗也大大降低（在两种设置中都高达2个数量级）。虽然设置看起来很极端，但当验证器正在引导或按需运行时（例如，用于网络规划或虚拟私有云的可达性分析），确实会发生这种情况。</span><br><span class="line">因此，我们得出结论，Flash对于大规模网络中的数据平面验证来说是快速且高效的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure6.png" class title="FLash-2&#x2F;figure6.png">
<h5 id="评估2：快速IMT的优势和稳健性。">评估2：快速IMT的优势和稳健性。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者分析了快速IMT作为一种独立的模型构建方法的好处，通过将子空间划分思想应用于大型网络中的Delta-net*和APKeep*，因为子空间划分可以广泛有效地用于大型网络。</span><br><span class="line">除了执行时间和内存消耗外，作者还计算了每个评估设置的断言运算数量.</span><br><span class="line">实验结果表：如下表3所示</span><br><span class="line">我们很容易看到：</span><br><span class="line">名为“LNet-smr子空间”的行显示了将子空间分区应用于LNet-smr中的所有子空间时的结果。</span><br><span class="line">我们观察到Delta-net*和APKeep*的模型更新时间更长，分别是LNet-ecmp中Flash的1.4倍（26s/19s）和1895倍，以及LNet-smr中的71倍（285s/4s）和251倍。</span><br><span class="line">在这两种设置中，Flash的内存占用空间也较小。Flash在LNet-smr中使用15MB，而Delta-net*和APKeep*分别使用6792MB和31MB。</span><br><span class="line">除了LNet-apsp子空间设置外，Flash还大幅减少了断言运算的数量（LNet-ecmp中的Delta-net*和APKeep分别为20倍和681倍，LNet-smr中分别为26倍和4倍）。</span><br><span class="line"></span><br><span class="line">完整性评估</span><br><span class="line">作者使用较小的网络，并报告文献中广泛使用的三种设置的结果：Airtel、Stanford跟和I2。</span><br><span class="line">表3的最后3行显示了结果。我们可以看到，APKeep*的模型更新时间是Flash的4.8-6.5倍。</span><br><span class="line">在这种较小的网络中，Delta-net*表现最好，模型更新时间仅为Flash的30-90%。对于一些大型网络也是如此，例如LNet-apsp子空间。</span><br><span class="line">然而，我们看到Delta-net*的断言运算数量高于Flash（在Airtel跟踪中高达141倍）。</span><br><span class="line">可能原因</span><br><span class="line">Delta-net*的效率来自于其简单、高效的数据结构，它可以有效地处理基于前缀的规则。然而，如LNet-smr和LNet-ecmp结果所示，对于非前缀规则，这种表示可能遭受显著的性能退化</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/table3.png" class title="FLash-2&#x2F;table3.png">
<h5 id="评估3：与CE2D合作时块大小阈值的影响。">评估3：与CE2D合作时块大小阈值的影响。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于更新可能在实际中不断到达，Flash可以选择更新反向模型，并在处理所有规则更新之前执行CE2D。</span><br><span class="line">此行为由块大小阈值（BST）参数配置B, 这迫使Flash在处理等于或大于B规则更新。</span><br><span class="line">为了了解此参数如何影响Flash的性能，作者改变了BST值，并测量了表3中使用的设置的模型构建时间。</span><br><span class="line">实验结果图：如下图7所示</span><br><span class="line">x轴表示BST值和FIB量表的比例，因为FIB量值决定了我们评估中的更新次数，并且在每个设置中变化很大。</span><br><span class="line">y轴是归一化的模型更新速度，计算为T基线/Tx，它对模型更新速度与基线相比的速度进行分类，其中BST值是无限的，并且在处理所有更新之后更新模型。</span><br><span class="line">作者观察到：</span><br><span class="line">&lt;1&gt;随着阈值的增加，总体趋势是模型更新速度将增加并保持在相对较高的水平。</span><br><span class="line">&lt;2&gt;在x≈0.04的情况下，大多数设置可以达到基线的60%以上和&gt;100%（LNet-apsp、LNet-ecmp和I2-trace）效率。</span><br><span class="line">&lt;3&gt;唯一的例外是LNet-smr子空间，当x≈0.04时，它仅达到～0.2，当x≈0.5时，它才达到＞0.8。</span><br><span class="line">&lt;4&gt;由于Flash在LNet-smr子空间中的加速大于70倍，因此Flash的速度仍然可以达到最先进的14倍以上。</span><br><span class="line">因此，我们得出结论，快速IMT在具有更大的块大小阈值的情况下更有效。然而，当阈值不小于FIB规模的4%时，仍然可以获得性能改进。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure7.png" class title="FLash-2&#x2F;figure7.png">
<h5 id="评估4：CE2D评估，证明其在极端环境下的有效性、性能优势和稳健性。">评估4：CE2D评估，证明其在极端环境下的有效性、性能优势和稳健性。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">&lt;1&gt;首先进行评估，以验证CE2D可以提供一致的早期检测结果。具体来说，我们使用I2OpenR循环设置运行模拟。我们使用Mininet来构建具有Internet2拓扑结构的网络。一个真正的OpenR实例在每个交换机上运行，并通过主机网络连接到Flash。</span><br><span class="line">&lt;2&gt;通过在Mininet中连续关闭两个链路（chic-alta和chic-kans）来触发FIB计算。</span><br><span class="line">作者将CE2D与两种策略进行了比较：</span><br><span class="line">&lt;1&gt;每次更新验证（PUV），它在处理单个规则更新后检查属性</span><br><span class="line">&lt;2&gt;块更新验证（BUV），其在处理更新块后检查性质。</span><br><span class="line">作者在验证器上记录每个交换机的FIB更新时间，以及验证器报告确定性结果的时间。</span><br><span class="line">实验结果图：如下图8所示</span><br><span class="line">结果分析：</span><br><span class="line">交叉点（x，y）表示在时间x接收到交换机y的FIB更新，因为链路断开事件被触发，并且颜色指示epoch标记。点（x，y）表示验证器策略y在时间x报告确定性结果，其中橙色表示有循环，蓝色表示没有循环。</span><br><span class="line">&lt;1&gt;两个同时发生的链路故障在每个交换机上多次触发FIB重新计算。对于PUV和BUV，验证器报告两个瞬态循环（橙色点），这与最终验证结果不一致。</span><br><span class="line">&lt;2&gt;Flash不会报告假阳性错误，并保证验证结果是一致的。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure8.png" class title="FLash-2&#x2F;figure8.png">
<h5 id="评估5：CE2D对长尾到达的好处。证明当长尾到达发生时，CE2D可以提高多少性能。">评估5：CE2D对长尾到达的好处。证明当长尾到达发生时，CE2D可以提高多少性能。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">&lt;1&gt;在发生循环的两种设置中评估了CE2D的效果：I2-OpenR/1buggy-loop-lt，I2-track-loop-lt。</span><br><span class="line">&lt;2&gt;对于每个设置，我们运行50个独立的随机试验，在每个试验中，我们通过配置一个随机节点在发送更新之前延迟60秒来模拟长尾效应。</span><br><span class="line">&lt;3&gt;测量Flash报告确定性结果的时间。</span><br><span class="line">实验结果图：如下图9所示</span><br><span class="line">结果分析：</span><br><span class="line">x轴是报告时间，y轴是累积分布函数（CDF）。将x轴的范围限制为[0ms，1000ms]：如果曲线在1000ms时没有达到y=1，则在60s时，即在接收到来自阻尼节点的更新后，会获得结果。</span><br><span class="line">&lt;1&gt;点(153.7ms,0.68)位于I2-OpenR/1buggy-loop-lt的曲线上，这表明Flash在68%的试验中可以在不到153.7ms的时间内检测到环路，这比60s的基线要小得多（&gt;390×）。</span><br><span class="line">&lt;2&gt;在I2-track-loop-lt中，Flash可以在所有试验中在760ms内早期检测到环路，从而实现79倍的加速。</span><br><span class="line">因此，我们得出的结论是，在长尾到达时，CE2D的改善可能相当普遍（68%至100%）和显著（79至&gt;390）。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure9.png" class title="FLash-2&#x2F;figure9.png">
<h5 id="评估6：多重阻尼交换机的影响。即研究了当存在多个阻尼交换机时对CE2D的影响。">评估6：多重阻尼交换机的影响。即研究了当存在多个阻尼交换机时对CE2D的影响。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">&lt;1&gt;作者使用I2-track-loop-lt设置，该设置使用来自Internet2数据集的真实网络拓扑和更新序列。</span><br><span class="line">&lt;2&gt;作者列举了阻尼设备的数量D从1到7。对于每个D，作者将Flash配置为使用CE2D检查循环，并运行50个独立的随机试验。</span><br><span class="line">实验结果图：如下图10所示</span><br><span class="line">结果分析：</span><br><span class="line">&lt;1&gt;在72.5%（即145/200）的情况下，Flash可以在800ms内检测到一致的环路，其速度是完整验证的75倍。</span><br><span class="line">&lt;2&gt;阻尼设备D随着时间的增长，成功的一致性早期检测的概率变得更低。例如，当D≤3时，CE2D在超过90%的情况下仍能在800ms内检测到误差，D=7约20%的情况下，即77.8%的交换机被阻尼。</span><br><span class="line">因此，我们得出结论，即使在数据平面的有限和部分知识的情况下，CE2D也可以早期检测到错误。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure10.png" class title="FLash-2&#x2F;figure10.png">
<h5 id="评估7：大规模网络中PAT的影响。">评估7：大规模网络中PAT的影响。</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">通过分析表3中的结果，我们展示了持久行动树（PAT，见§3.4）的效果。总的模型更新时间包括创建和删除等价类的时间（表示为Tec，由Flash中的持久操作树（PAT）处理，与断言操作的数量无关），以及处理断言的时间（称为Top）。</span><br><span class="line">结果分析：</span><br><span class="line">在表3中，我们看到，在前3个大规模网络设置中，模型构建时间的改进大于Flash对APKeep*的#断言运算的改进，例如，LNet-apsp分别为15x和5x。</span><br><span class="line">原因是在较小的网络中，模型构建时间由Top主导，性能增益主要来自于#断言运算的减少。同时，在大型网络中，Tec在整体性能方面占据主导地位，Flash从PAT的性能增益中获益更多</span><br></pre></td></tr></table></figure>
<h5 id="评估8：MR2的影响。即为了更好地理解MR2（§3-2）如何对Flash的整体性能增益做出贡献">评估8：MR2的影响。即为了更好地理解MR2（§3.2）如何对Flash的整体性能增益做出贡献</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">&lt;1&gt;作者对模型构建中的3个阶段进行了细分分析：计算原子覆盖（Map）、覆盖聚合（即Reduce I/II）和应用覆盖。</span><br><span class="line">&lt;2&gt;作者测量APKeep*、Flash和Flash变体（称为Flash（逐条规则更新模式））每个阶段的总时间，其中块大小阈值设置为1。</span><br><span class="line">实验结果图：如下图11所示</span><br><span class="line">结果分析：</span><br><span class="line">图11显示了APKeep*、Flash（每次更新模式）和Flash在I2-track中的时间细分。</span><br><span class="line">&lt;1&gt;虽然Flash引入了一些覆盖聚合的开销（0.42s），但与APKeep*相比，计算原子覆盖（3.85倍）和应用覆盖（12.30倍）的速度加快了。</span><br><span class="line">&lt;2&gt;在Flash（每次更新模式）中应用覆盖所需的时间（4.84s）比APKeep*（4.55s）更长，因为交叉乘积计算并没有针对单个规则更新进行优化。</span><br><span class="line">因此，我们得出结论，通过覆盖聚合，MR2使Flash能够通过大幅减少计算无原子冲突模型覆盖和应用聚合覆盖的时间来提高性能。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure11.png" class title="FLash-2&#x2F;figure11.png">
<h5 id="评估9：递减验证图的效率。即展示了使用递减验证图方法（§4-2）对基于正则表达式的需求执行一致早期检测的效率">评估9：递减验证图的效率。即展示了使用递减验证图方法（§4.2）对基于正则表达式的需求执行一致早期检测的效率</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">&lt;1&gt;作者使用LNet-apsp子空间设置并检查所有对ToR到ToR的可达性。</span><br><span class="line">&lt;2&gt;Flash总共生成5376个验证图，每个子空间验证器生成48个验证图。每个交换机的规则插入都打包为一个batch。</span><br><span class="line">&lt;3&gt;作者在处理每个batch次后验证可达性，并使用（1）递减图查询（DGQ，见§4.2）方法和（2）模型遍历（MT，即使用深度优先遍历从每个源ToR遍历模型）来测量单个子空间验证器的验证执行时间。</span><br><span class="line">实验结果图，如下图12所示</span><br><span class="line">结果分析：</span><br><span class="line">图12显示了验证时间的CDF。</span><br><span class="line">&lt;1&gt;DGQ（蓝色）比MT（橙色）更靠近y轴。DGQ和MT的中位数、平均值、99%和最长时间分别为0.58/0.84/4.74/19.57ms和772.98/1522.22/5513.76/7466.87ms。</span><br><span class="line">&lt;2&gt;与MT相比，Flash将99%的执行时间提高了~1163×（4.74ms vs.s.5513.76ms）。</span><br><span class="line">因此，我们可以得出结论，递减验证图方法大大提高了基于正则表达式的需求的验证性能，并实现了高效一致的早期检测。</span><br></pre></td></tr></table></figure>
<img src="/2023/03/30/FLash-2/figure12.png" class title="FLash-2&#x2F;figure12.png">
<h5 id="评估10：计算开销">评估10：计算开销</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验设计：</span><br><span class="line">两种部署</span><br><span class="line">&lt;1&gt;部署专用服务器以进行持续验证的设置</span><br><span class="line">结果分析：</span><br><span class="line">对于LNet-ecmp，Flash为每个pod划分一个子空间，因此总共有112个子空间。</span><br><span class="line">每个子空间验证器需要1 (v)个CPU，211MB内存用于反向模型，336MB内存用于验证图，以检查所有对ToR可达性，并且每台机器需要&lt;4GB内存来运行JVM并存储规则。</span><br><span class="line">因此，总计算开销为112 (v)个CPU，&lt;62GB（61.26GB）（用于模型和验证图）+4GB（用于规则和JVM）内存。</span><br><span class="line">如果子空间验证器部署在k个具有专用资源的机器，每台机器需要112/k (v)CPU和62/k + 4GB内存。</span><br><span class="line">为了了解数据中心的资源成本，我们在2022/7/1应用了AWS EC2（美国俄亥俄州）[52]的可用性和定价，以获得Flash需要4个c6g.8xlarge（32 vCPU和64GB内存）实例。估计费用为2.74美元/小时。</span><br><span class="line">&lt;2&gt;一次性部署设置，其中操作员使用按需计算资源来验证LNet-ecmp</span><br><span class="line">结果分析：</span><br><span class="line">&lt;1&gt;选择4个c6g.8xlarge（32个vCPU和64GB内存）实例，Flash在21秒内完成一次性验证：1秒用于接收规则更新，19秒用于模型构建，939ms用于可达性检查。</span><br><span class="line">&lt;2&gt;假设每个实例运行1分钟并使用WS定价数据，则系统成本为4.352美元/小时或0.07美元/次</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>FLash</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA开发</title>
    <url>/2023/03/26/JAVA%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="JAVA开发">JAVA开发</h2>
<span id="more"></span>
<h3 id="流程">流程</h3>
<blockquote>
<p>初始化模型（规则树）</p>
<p>将规则添加到前缀树中</p>
<p>提取前缀树中规则</p>
<p>模型更新</p>
<p>验证</p>
</blockquote>
<h3 id="根据端口名获取端口（不存在直接添加）">根据端口名获取端口（不存在直接添加）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Port</span> <span class="variable">p</span> <span class="operator">=</span> device.getPort(<span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Port <span class="title function_">getPort</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    nameToPort.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Port</span>(name, <span class="built_in">this</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nameToPort.get(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则插入树结构">规则插入树结构</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndexedRules <span class="title function_">traverseSrc</span><span class="params">(Rule rule, ArrayList&lt;Rule&gt; ret, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">IndexedRules</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">null</span>) t.read(rule, ret, size);</span><br><span class="line">        <span class="type">long</span> <span class="variable">srcIp</span> <span class="operator">=</span> rule.getSrc();<span class="comment">//获取IP</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rule.getSrcSuffix(); i++) &#123;<span class="comment">//遍历前缀</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">bit</span> <span class="operator">=</span> (srcIp &gt;&gt; i) &amp; <span class="number">1</span>;右移i位 并将其结果与<span class="number">1</span>进行and运算</span><br><span class="line">            t = t.buildNext(bit == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="literal">null</span>) t.read(rule, ret, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">null</span>) t.exploreSrc(rule, ret, size);</span><br><span class="line">        <span class="keyword">return</span> t.traverse(rule, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//read() method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(Rule rule, ArrayList&lt;Rule&gt; ret, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.dst == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">IndexedRules</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.dst;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">null</span>) ret.addAll(t.getRules());</span><br><span class="line">        <span class="type">long</span> <span class="variable">dstIp</span> <span class="operator">=</span> rule.getMatch().longValue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rule.getPrefix() - (<span class="number">32</span> - size); i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">bit</span> <span class="operator">=</span> (dstIp &gt;&gt; (size - <span class="number">1</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">            t = (bit == <span class="number">0</span>) ? t.left : t.right;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="literal">null</span>) ret.addAll(t.getRules());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">null</span>) t.explore(ret);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//buildNext() method</span></span><br><span class="line">    <span class="keyword">private</span> IndexedRules <span class="title function_">buildNext</span><span class="params">(<span class="type">int</span> flag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.left = <span class="keyword">new</span> <span class="title class_">IndexedRules</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.right = <span class="keyword">new</span> <span class="title class_">IndexedRules</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right;    </span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//explore() method</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">explore</span><span class="params">(ArrayList&lt;Rule&gt; ret)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.explore(ret);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.explore(ret);</span><br><span class="line">        ret.addAll(<span class="built_in">this</span>.getRules());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//traverse() method</span></span><br><span class="line">    <span class="keyword">public</span> IndexedRules <span class="title function_">traverse</span><span class="params">(Rule rule, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.dst == <span class="literal">null</span>) <span class="built_in">this</span>.dst = <span class="keyword">new</span> <span class="title class_">IndexedRules</span>();</span><br><span class="line">        <span class="type">IndexedRules</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.dst;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">dstIp</span> <span class="operator">=</span> rule.getMatch().longValue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rule.getPrefix() - (<span class="number">32</span> - size); i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">bit</span> <span class="operator">=</span> (dstIp &gt;&gt; (size - <span class="number">1</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">            t = t.buildNext(bit == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//exploreSrc() method</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exploreSrc</span><span class="params">(Rule rule, ArrayList&lt;Rule&gt; ret, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.read(rule, ret, size);</span><br><span class="line">            <span class="built_in">this</span>.left.exploreSrc(rule, ret, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.read(rule, ret, size);</span><br><span class="line">            <span class="built_in">this</span>.right.exploreSrc(rule, ret, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">test</span></span><br><span class="line"><span class="comment">default rule 0/0 32 -&gt;srcIp=0 getSrcSuffix=0 size=32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模拟测试</p>
<p>假设存在三条转发规则</p>
<p>rule 1 192.168.1.1/24  port1<br>
rule 2 192.168.1.2/16  port2<br>
rule 3 192.168.1.1/25  port3</p>
<p>存在默认规则</p>
<p>rule default 0.0/24 default</p>
<p>过程</p>
<p>1.添加默认规则</p>
<p>调用traverseSrc(default, null, 32)</p>
<blockquote>
<p>调用traverse(default,32)</p>
</blockquote>
<p>t = t.dst</p>
<p>2.添加规则rule 1 rule 2 rule 3</p>
<p>for循环遍历规则集合[rule 1,rule 2,rule 3]</p>
<p>添加规则rule 1</p>
<blockquote>
<p>调用traverseSrc(default, null, 32)</p>
<blockquote>
<p>执行</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>后端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FLash-3</title>
    <url>/2023/04/01/FLash-3/</url>
    <content><![CDATA[<h2 id="Flash-解决更新风暴、长尾到达的最新数据平面验证-学习4">Flash-解决更新风暴、长尾到达的最新数据平面验证-学习4</h2>
<span id="more"></span>
<h3 id="相关工作">相关工作</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大规模网络的网络验证。</span><br><span class="line">&lt;1&gt;由于其重要性，各种研究已经对大规模网络的网络验证进行了研究。</span><br><span class="line">&lt;2&gt;一些设计侧重于控制平面，这与Flash所关注的数据平面验证是互补的，而一些设计仅适用于特定的网络结构和特定的需求，而Flash针对的是更通用的网络和需求。</span><br><span class="line">&lt;3&gt;Libra提出通过分布式计算来扩展大规模网络的验证。它将头部空间划分为最小的原子子空间，其中每个子空间必须具有相同的转发行为，并且本质上是Flash中的等价类，并将这些子空间的验证分发给一组验证器。</span><br><span class="line">&lt;4&gt;Flash中子空间划分的设计是受Libra的启发。然而，Flash中子空间分区的主要目的是减少FIB更新的排队和内存成本。因此，Flash允许在一个子空间中验证多个EC</span><br><span class="line">&lt;5&gt;一些大型网络使用基于仿真的控制平面验证工具。Flash可以通过验证生成的规则来很好地补充这些研究。最近的研究是这一方向的先驱。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据平面验证。</span><br><span class="line">&lt;1&gt;数据平面表示是数据平面验证的核心数据结构。一些数据平面验证工具使用流表(SDN)表示，并在此基础上开发计算模型（例如，SAT模型[17]、头部空间代数和分组转换函数[18]以及数据日志模型[27]）。</span><br><span class="line">&lt;2&gt;另一组数据平面验证工具使用等效类作为数据平面表示。等价类将头部空间分析和需求验证解耦，如果EC的数量较少，这两个步骤都可以有效地执行。</span><br><span class="line">&lt;3&gt;最近的研究也通过维护多组EC和延迟计算叉积来缓解EC的爆炸。</span><br><span class="line">&lt;4&gt;EC方法还受益于有效的数据结构来操作头部空间：Delta-net[25]开发了一种基于间隔的数据结构，该结构在处理基于前缀的规则时是有效的，而其他方法（例如，APKeep[26]和Flash）在更通用的设置下使用二进制决策图（BDD）来提高内存效率。</span><br><span class="line">&lt;5&gt;在EC方法中，Flash是第一个设计高效数据结构来存储和操作操作的方法，只有在应用于大规模网络时，这一点才变得至关重要。</span><br><span class="line">&lt;6&gt;DNA[47]还独立开发了两种批量更新的想法。具体而言，“批量插入和删除”的想法与“删除取消更新”（算法1中的L1）相同，“同一设备上的批量转发行为”的想法类似于Flash中的“按操作聚合”（Reduce I），但限制更大：聚合的更新在更新前后必须具有相同的操作。</span><br><span class="line">&lt;7&gt;随着Flash对块更新问题进行了更深入的分析，Fast IMT中开发的优化是通用的，可以应用于其他EC实现。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络中的自动机理论。</span><br><span class="line">&lt;1&gt;递减验证图的想法是由将自动机理论应用于策略路由的研究推动的。这些研究将网络和路由约束建模为自动化。通过计算乘积自动机，这些研究可以识别满足路由约束的网络路径。</span><br><span class="line">&lt;2&gt;Flash也计算乘积自动机，但将其用于验证目的，并结合最近的快速可达性检查方法[41]。</span><br></pre></td></tr></table></figure>
<h3 id="讨论">讨论</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者Flash可能扩展的三个方面：需求规范、数据平面模型和实现。</span><br><span class="line"></span><br><span class="line">需求规范。</span><br><span class="line">&lt;1&gt;目前，Flash使用路径正则表达式（PRE）来表达需求规范。虽然PRE简单易懂，但它通常需要最短路径等假设来避免状态爆炸，并且不能轻易扩展以支持非最短路径算法。</span><br><span class="line">&lt;2&gt;由于Flash使用需求规范来构建对所有有效路径进行编码的递减验证图（DVG），因此一个潜在的扩展是直接将DVG作为输入。</span><br><span class="line">&lt;3&gt;因此，Flash可能与许多SDN编程语言（例如[42，43，55-59]）的前端接口，这些语言也计算所有有效路径的集合。</span><br><span class="line"></span><br><span class="line">数据平面模型。</span><br><span class="line">&lt;1&gt;Flash专注于数据平面模型，在该模型中，数据包仅基于报头转发，不存在报头重写，因为与运营商的讨论表明，报头重写大多发生在我们目标大规模网络中的终端主机（例如[60]）。</span><br><span class="line">&lt;2&gt;然而，可能需要将Flash扩展到有状态路由（例如，P4[61]和NPL[62]），或者支持常见的报头重写，例如NAT或隧道。</span><br><span class="line">&lt;3&gt;状态路由需要扩展到快速IMT。具体而言，转发功能模型b(ℎ) 需要修改为b(ℎ,s),其中s表示状态。</span><br><span class="line">&lt;4&gt;如果这些操作可能会更改标头或状态，则需要扩展到CE2D。有两个方向可以处理Flash中的头/状态重写。</span><br><span class="line">&lt;5&gt;第一个方向（例如，[26]）是保证任何数据包，如果被重写，在重写之前和之后都属于精确的一个EC。</span><br><span class="line">&lt;6&gt;另一个方向是启用递归查询（例如，[54]）。</span><br><span class="line">&lt;7&gt;必须扩展CE2D，例如，通过在不同EC的递减验证图之间添加链接。当可以在不同步的节点上执行报头重写时，随着不确定性的增加，CE2D的好处可能会减少。这两种方法都可以破坏子空间分区，因为头重写后的EC可能属于另一个分区，甚至属于另一台机器。</span><br><span class="line"></span><br><span class="line">实施</span><br><span class="line">&lt;1&gt;Flash已经提供了许多优化。进一步提高Flash性能优势的一个潜在扩展是利用并行性和管道技术。</span><br><span class="line">&lt;2&gt;目前，子空间验证器的快速IMT和CE2D在同一核心上运行。有了更多的CPU，我们可以将这两个步骤解耦，并并行化每个EC的需求验证。</span><br><span class="line">&lt;3&gt;快速IMT也可以通过利用最近的BDD库（例如[63]）来并行化，这些库允许高效的并发BDD/谓词操作。</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;1&gt;作者设计了Flash，这是一个快速且可扩展的系统，它解决了大规模网络数据平面验证中的两个重要问题：更新风暴和长尾更新到达。</span><br><span class="line">&lt;2&gt;Flash提出了两个新想法：通过优化块更新处理实现快速逆模型转换，以及通过部分完整的数据平面信息实现一致验证的一致、高效、早期检测。</span><br><span class="line">&lt;3&gt;在大规模数据集上进行的大量实验证明了其有效性和效率。</span><br></pre></td></tr></table></figure>
<h3 id="附录">附录</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转发模型（基于规则的表示）：三部分：匹配断言r.pred∈P，优先级r.pr∈N，输出向量(r,y) -&gt; 模拟FIB转发</span><br><span class="line">逆模型（基于等价类的表示）：每个逆模型是一组(p,y)对，其中p∈P是断言，y∈Y是输出向量。显然，模型的空间是P×Y的子集。然而，逆模型必须满足约束条件，如定义6所示。我们定义了一个布尔函数im，它取P×Y的子集，如果它是逆模型，则返回1，否则返回0。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>FLash</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端开发注意事项</title>
    <url>/2023/03/26/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="Java后端开发注意事项">Java后端开发注意事项</h2>
<span id="more"></span>
<h3 id="异常处理">异常处理</h3>
<h4 id="try-catch-finally">try-catch-finally</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    //代码可能存在异常</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception exception)</span><br><span class="line">&#123;</span><br><span class="line">    //捕获异常</span><br><span class="line">    //1.异常发生时，系统将异常封装成Exception对象exception</span><br><span class="line">    //2.传值给catch</span><br><span class="line">    //3.获取异常对象时，程序员自己处理</span><br><span class="line">    //4.若try中代码无异常，则catch不会发生</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    //1.无论try中代码是否存在异常，始终执行finally    </span><br><span class="line">    //2.通常将释放资源的代码，放在finally关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="throws">throws</h4>
<blockquote>
<p>main方法由JVM调用，main方法调用 f1 方法，f1 方法调用 f2 方法，如果 f2 方法发生异常，有两种方案，分别是 try-catch-finally 和 throws ，f2 使用 throws 方法，返回给 f1，f1也可以同样选择throws方法，返回给 main 方法，最终返回到 JVM。而 JVM 对处理异常的发生极为粗暴（1.输出异常信息。2. 退出程序）。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>[x]</p>
</li>
</ul>
<h3 id="数组">数组</h3>
<h4 id="数组复制">数组复制</h4>
<blockquote>
<p>java.lang.System.arraycopy() 方法从指定的源数组复制一个数组，从指定位置开始，到目标数组的指定位置。 数组组件的子序列从 src 引用的源数组复制到 dest 引用的目标数组。复制的组件数等于 length&lt; /b&gt; 参数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void arraycopy(Object src,</span><br><span class="line">                             int srcPos,</span><br><span class="line">                             Object dest,</span><br><span class="line">                             int destPos,</span><br><span class="line">                             int length)</span><br><span class="line">//将src数组里从索引为srcPos的元素开始, 复制到数组dest里的索引为destPos的位置, 复制的元素个数为length个. </span><br><span class="line">//example</span><br><span class="line">int[] arr1 =&#123;1,2,3,4,5&#125;;arrayCopy(arr1, 3, arr1, 2, 2);</span><br><span class="line">arr1 = &#123;1,2,4,5,4,5&#125; //相当于删除3</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>后端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>My New Post</title>
    <url>/2023/03/24/My-New-Post/</url>
    <content><![CDATA[<h2 id="第一次测试博客">第一次测试博客</h2>
<span id="more"></span>]]></content>
      <tags>
        <tag>hexo使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/01/hello-world/</url>
    <content><![CDATA[<h2 id="hexo使用">hexo使用</h2>
<span id="more"></span>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo使用</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的使用</title>
    <url>/2023/03/26/learning/</url>
    <content><![CDATA[<h2 id="markdown的使用">markdown的使用</h2>
<span id="more"></span>
<h3 id="使用-表示标题">使用&quot;#&quot;表示标题</h3>
<h3 id="其中-“的含义是引用-嵌套时多加一个”-如下">其中&quot;&gt;“的含义是引用 嵌套时多加一个”&gt;&quot;如下</h3>
<blockquote>
<p>这是我的引用<br>
不错</p>
<blockquote>
<p>你好</p>
</blockquote>
</blockquote>
<h3 id="三个反引号-这个符号的位置在键盘的-ESC下面-开头然后用三个反引号结尾">三个反引号&quot;```&quot;(这个符号的位置在键盘的 ESC下面)开头然后用三个反引号结尾</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<h3 id="一个反引号-表示行内代码块">一个反引号&quot;`&quot;表示行内代码块</h3>
<p><code>HashMap&lt;String,String&gt; test = new HashMap&lt;&gt;();</code></p>
<h3 id="表格使用-表示">表格使用&quot;|&quot;表示</h3>
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody>
<tr>
<td>你好</td>
<td>你好</td>
</tr>
</tbody>
</table>
<h3 id="超链接">超链接</h3>
<p><a href="https://markdown.com.cn">超链接</a><br>
使用&lt;&gt;可以很方便地把URL或者email地址变成可点击的链接<br>
<a href="https://www.baidu.com">https://www.baidu.com</a></p>
<h3 id="显示图片的两种方式-一种是仅显示图片-另一种时还可以显示链接">显示图片的两种方式 一种是仅显示图片 另一种时还可以显示链接</h3>
<p><img src="/2023/03/26/learning/WebRoot/Web/picture/cloud.png" alt="这是图片"><br>
<a href="https://cn.bing.com/images/search?view=detailV2&amp;ccid=wc%2fdCG%2fK&amp;id=2A67B025EDB55DFCC3EACFBF5B0CD513CC71AE39&amp;thid=OIP.wc_dCG_KbIKZwMdtD3gL2QHaEt&amp;mediaurl=https%3a%2f%2fpic3.zhimg.com%2fv2-58d652598269710fa67ec8d1c88d8f03_r.jpg%3fsource%3d1940ef5c&amp;exph=1304&amp;expw=2048&amp;q=%e5%9b%be%e7%89%87&amp;simid=607986392600622860&amp;FORM=IRPRST&amp;ck=7906E4DE8F66609504206A4E0B045F1E&amp;selectedIndex=0&amp;ajaxhist=0&amp;ajaxserp=0"><img src="/2023/03/26/learning/WebRoot/Web/picture/cloud.png" alt="这是图片"></a></p>
<h3 id="粗体-斜体-换行需要在段落后面加两个空格">粗体&quot;**&quot; 斜体&quot;*&quot; 换行需要在段落后面加两个空格</h3>
<p>I HAVE A <strong>DOG</strong><br>
I HAVE A <em>DOG</em></p>
<h3 id="创建列表-使用数字加">创建列表 使用数字加&quot;.&quot;</h3>
<ol>
<li class="lvl-3">
<p>你好</p>
</li>
<li class="lvl-3">
<p>你不好</p>
<h3 id="创建无序列表，请在每个列表项前面添加破折号-、星号-或加号-。缩进一个或多个列表项可创建嵌套列表">创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表</h3>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>你好</p>
</li>
<li class="lvl-2">
<p>你好啊</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>你好</p>
<h3 id="分隔符请在单独一行上使用三个或多个星号-、破折号-—-或下划线">分隔符请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___)</h3>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>markdown使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Topotest1</title>
    <url>/2023/03/31/Topotest1/</url>
    <content><![CDATA[<h2 id="验证ensp中可达性是否与项目中算法可达性结果一致">验证ensp中可达性是否与项目中算法可达性结果一致</h2>
<span id="more"></span>
<h3 id="环境准备">环境准备</h3>
<h4 id="拓扑图">拓扑图</h4>
<img src="/2023/03/31/Topotest1/topo.png" class title="Topotest1&#x2F;topo.png">
<h4 id="ACL图（在数据库中显示-对应于数据库2023-3-31）">ACL图（在数据库中显示 对应于数据库2023.3.31）</h4>
<img src="/2023/03/31/Topotest1/acl.png" class title="Topotest1&#x2F;acl.png">
<h3 id="结果比较">结果比较</h3>
<h4 id="ensp">ensp</h4>
<table>
<thead>
<tr>
<th style="text-align:center">源设备</th>
<th style="text-align:center">目标含义</th>
<th style="text-align:left">是否可达</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:center">ACC4.VLAN10</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:center">ACC5.VLAN20</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:center">ACC2.VLAN30</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:center">ACC6.VLAN40</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">CORE.VLAN100</td>
<td style="text-align:center">ACC7.VLAN50</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<h4 id="项目中可达性矩阵">项目中可达性矩阵</h4>
<img src="/2023/03/31/Topotest1/topomatrix.png" class title="Topotest1&#x2F;topomatrix.png">
<h3 id="结论">结论</h3>
<p>实验结果一致</p>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>switch</title>
    <url>/2023/03/25/switch/</url>
    <content><![CDATA[<h2 id="交换机的使用方法介绍">交换机的使用方法介绍</h2>
<span id="more"></span>
<p>目前，主流厂商可分为思科（Cisco）、华为、锐捷、H3C</p>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>系统命令</title>
    <url>/2023/03/26/windows%E4%B8%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="windows下文件操作">windows下文件操作</h2>
<span id="more"></span>
<h3 id="查看文件MD5-SHA1-256">查看文件MD5\SHA1\256</h3>
<blockquote>
<p>CMD</p>
<p>certutil -hashfile D:\emp.png MD5</p>
<p>certutil -hashfile D:\ubuntu_18.iso SHA1</p>
<p>certutil -hashfile D:\setup.exe SHA256</p>
</blockquote>
<p><img src="/2023/03/26/windows%E4%B8%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/C:%5CUsers%5C%E7%94%B0%E6%99%93%E6%BB%A8%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-11-27-09-16-50-image.png" alt></p>
]]></content>
      <tags>
        <tag>系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>华为拓扑测试</title>
    <url>/2023/03/26/%E5%8D%8E%E4%B8%BA%E6%8B%93%E6%89%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="华为拓扑测试">华为拓扑测试</h2>
<span id="more"></span>
<p>首先创建拓扑图</p>
<p><img src="/2023/03/26/%E5%8D%8E%E4%B8%BA%E6%8B%93%E6%89%91%E6%B5%8B%E8%AF%95/C:%5CUsers%5C%E7%94%B0%E6%99%93%E6%BB%A8%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-11-15-15-10-16-image.png" alt></p>
<h3 id="设计目标">设计目标</h3>
<ol>
<li class="lvl-3">
<p>禁止192.168.30.2 访问 192.168.50.0/24</p>
</li>
<li class="lvl-3">
<p>禁止ACC4.VLAN10访问ACC6.VLAN40</p>
</li>
<li class="lvl-3">
<p>禁止ACC2.VLAN30访问ACC6.VLAN40</p>
</li>
<li class="lvl-3">
<p>禁止ACC3(192.168.40.2)可以从CORE的所有接口转发出去</p>
</li>
<li class="lvl-3">
<p>NULL</p>
</li>
<li class="lvl-3">
<p>允许 192.168.10.2 访问192.168.50.0/24</p>
</li>
<li class="lvl-3">
<p>允许 192.168.10.4 访问192.168.50.0/24</p>
</li>
<li class="lvl-3">
<p>禁止192.168.10.0/24 访问 192.168.50.0/24</p>
</li>
</ol>
<h3 id="方案">方案</h3>
<p>ACC3上部署ACL 实现目标6 7 8</p>
<blockquote>
<p>使用简化流策略，作用于接口。仅使用了基本ACL，满足了基本ACL尽量离目标近</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl name acl3 2001;</span><br><span class="line">rule 5 permit source 192.168.10.4 0;</span><br><span class="line">rule 10 permit source 192.168.10.2 0;</span><br><span class="line">rule 15 deny source 192.168.10.0 0.0.0.255;</span><br><span class="line"></span><br><span class="line">interface ge0/0/3</span><br><span class="line">traffic-filter inbound acl name acl3 </span><br></pre></td></tr></table></figure>
<p>CORE上部署ACL 实现目标1 3 4</p>
<blockquote>
<p>使用流策略，既作用于接口又作用于VLAN。仅使用扩展ACL，扩展ACL离源设备近</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl number 3002;</span><br><span class="line">rule 5 deny ip source 192.168.30.0 0.0.0.255 destination 192.168.50.0 0.0.0.255</span><br><span class="line">acl number 3003;</span><br><span class="line">rule 10 deny ip source 192.168.30.0 0.0.0.255 destination 192.168.40.0 0.0.0.255</span><br><span class="line">acl number 3004;</span><br><span class="line">rule 5 deny ip destination 192.168.40.2 0</span><br><span class="line"></span><br><span class="line">#配置流分类</span><br><span class="line">traffic classifier c1;</span><br><span class="line">if-match acl 3002;</span><br><span class="line">traffic classifier c2;</span><br><span class="line">if-match acl 3003;</span><br><span class="line">traffic classifier c3;</span><br><span class="line">if-match acl 3004;</span><br><span class="line">#配置流行为</span><br><span class="line">traffic behavior b1;</span><br><span class="line">permit;</span><br><span class="line">#配置流策略</span><br><span class="line">traffic policy p1;</span><br><span class="line">classifier c1 behavior b1;</span><br><span class="line">traffic policy p2;</span><br><span class="line">classifier c2 behavior b1;</span><br><span class="line">traffic policy p3;</span><br><span class="line">classifier c3 behavior b1;</span><br><span class="line">traffic-policy p3 global outbound;#全局视图</span><br><span class="line">#应用流策略</span><br><span class="line">int g0/0/2</span><br><span class="line">traffic-policy p1 inbound</span><br><span class="line">vlan 30</span><br><span class="line">traffic-policy p2 inbound</span><br></pre></td></tr></table></figure>
<p>ACC1上部署ACL 实现目标2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl number 3005;</span><br><span class="line">rule 5 deny ip source 192.168.10.0 0.0.0.255 destination 192.168.40.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">#配置流分类</span><br><span class="line">traffic classifier c1;</span><br><span class="line">if-match acl 3005;</span><br><span class="line">#配置流行为</span><br><span class="line">traffic behavior b1;</span><br><span class="line">permit;</span><br><span class="line">#配置流策略</span><br><span class="line">traffic policy p1;</span><br><span class="line">classifier c1 behavior b1;</span><br><span class="line">#应用流策略</span><br><span class="line">vlan 10</span><br><span class="line">traffic-policy p1 inbound</span><br></pre></td></tr></table></figure>
<h3 id="Ensp中删除ACL及流策略、简化流策略">Ensp中删除ACL及流策略、简化流策略</h3>
<p><img src="/2023/03/26/%E5%8D%8E%E4%B8%BA%E6%8B%93%E6%89%91%E6%B5%8B%E8%AF%95/C:%5CUsers%5C%E7%94%B0%E6%99%93%E6%BB%A8%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-11-15-16-37-27-image.png" alt></p>
<h4 id="删除流策略">删除流策略</h4>
<blockquote>
<p>如果需要删除的流策略已经应用到全局、接口或VLAN，则不允许直接删除该策略，需要先在相应的视图下执行<strong>undo traffic-policy</strong>命令取消对该策略的应用，然后再到全局执行<strong>undo traffic policy</strong>命令完成删除。如果没有应用，则可以直接删除。</p>
</blockquote>
<p><img src="/2023/03/26/%E5%8D%8E%E4%B8%BA%E6%8B%93%E6%89%91%E6%B5%8B%E8%AF%95/C:%5CUsers%5C%E7%94%B0%E6%99%93%E6%BB%A8%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-11-15-16-35-33-image.png" alt></p>
<h4 id="删除ACL规则">删除ACL规则</h4>
<blockquote>
<p>执行命令<strong>undo acl</strong> { [ <strong>number</strong> ] <em>acl-number</em> | <strong>all</strong> }或<strong>undo acl</strong> <strong>name</strong> <em>acl-name</em>，删除ACL。</p>
<p>执行命令<strong>undo acl ipv6</strong> { <strong>all</strong> | [ <strong>number</strong> ] <em>acl6-number</em> }或<strong>undo acl ipv6</strong> <strong>name</strong> <em>acl6-name</em>，删除ACL6。</p>
</blockquote>
<h4 id="删除简化流策略">删除简化流策略</h4>
<blockquote>
<p>进入相应的视图下执行命令undo traffic-filter inbound acl aclnum</p>
</blockquote>
<h4 id="保存配置">保存配置</h4>
<blockquote>
<p>华为保存配置时，需要输入save；</p>
<p>Cisco保存配置时，需要输入copy running-config start-config</p>
</blockquote>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>netTopo</title>
    <url>/2023/03/26/%E5%BE%85%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<h2 id="项目仍存在的问题">项目仍存在的问题</h2>
<span id="more"></span>
<ol>
<li class="lvl-3">命名ACL处理</li>
<li class="lvl-3">计算可达性按钮和显示路径结果合二为一</li>
<li class="lvl-3">前端显示多端文本<br>
<code>textarea 标签定义多行的文本输入控件</code><br>
<code>readonly 方法用于规定文本区为只读</code><br>
<a href="https://www.w3school.com.cn/tags/tag_textarea.asp">textarea用法</a></li>
<li class="lvl-3">点击前端按钮时，执行某方法，显示正在加载中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;reachSpinner&quot; ng-show=&quot;shared.isComputingReach == true&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;/netTopo/Web/picture/loading.gif&quot;/&gt;</span><br><span class="line">    &lt;h1&gt;可达性计算中&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">其中添加一个reachSpinner.css类用于渲染</span><br><span class="line">#reachSpinner &#123;</span><br><span class="line">position: fixed;</span><br><span class="line">top: 0; left: 0;</span><br><span class="line">width: 100vw; height: 100vh;</span><br><span class="line">z-index: 9999;</span><br><span class="line">background: rgba(0, 0, 0, 0.7);</span><br><span class="line">transition: opacity 0.2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* (B) CENTER LOADING SPINNER */</span><br><span class="line">#reachSpinner img &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%; left: 50%;</span><br><span class="line">    transform: translate(-50%);</span><br><span class="line">&#125;</span><br><span class="line">#reachSpinner h1 &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 60%; left: 50%;</span><br><span class="line">    transform: translate(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>删除临时目录及文件</p>
</li>
</ol>
<blockquote>
<p>不能直接使用delete命令删除存在文件的目录，需先将目录下的文件删除后，再删除该目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File dir = new File(path);</span><br><span class="line">File[] listFiles = dir.listFiles();</span><br><span class="line">if(listFiles != null)</span><br><span class="line">&#123;</span><br><span class="line">    for(File file : listFiles)</span><br><span class="line">    &#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dir.delete();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>netTopo项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Echart JS</title>
    <url>/2023/03/26/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前端学习">前端学习</h2>
<span id="more"></span>
<blockquote>
<p>本次学习了包含HTML JS Echarts的内容</p>
</blockquote>
<h3 id="如何实现跳转页面？">如何实现跳转页面？</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.open(URL,name,specs,replace)</span><br></pre></td></tr></table></figure>
<p>具体参考方法可以考虑网址<br>
<a href="https://www.runoob.com/jsref/met-win-open.html">window.open()用法</a></p>
<h3 id="js如何实现跳转页面的同时传值？">js如何实现跳转页面的同时传值？</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let params = &#123;</span><br><span class="line">&quot;allnodes&quot;:data.cloudnodes,</span><br><span class="line">&quot;reachpaths&quot;:data.reachpaths</span><br><span class="line">&#125;;</span><br><span class="line">window[&quot;filter&quot;] = params;</span><br></pre></td></tr></table></figure>
<p>从原页面想要传输两个数据:allnodes 与 reachpaths<br>
要从跳转后页面的数据，只需要以下情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">let receive = window.opener[&quot;filter&quot;];</span><br><span class="line">let allnodes = receive[&quot;allnodes&quot;];</span><br><span class="line">let reachpaths = receive[&quot;reachpaths&quot;];</span><br></pre></td></tr></table></figure>
<p>至此便可以实现从一个页面到另一个页面的传值<br>
#<strong>注意</strong>：&quot;filter&quot;是自定义的<br>
具体参考方法:<br>
<a href="https://www.runoob.com/jsref/prop-win-opener.html">window.opner()用法</a></p>
<h3 id="用什么框架可以渲染矩阵？">用什么框架可以渲染矩阵？</h3>
<p>目前我是采用Echarts中<strong>热力图</strong>来渲染矩阵<br>
Echarts使用：<br>
<a href="https://echarts.apache.org/zh/index.html">Echarts使用</a><br>
Echarts实例：<br>
<a href="https://echarts.apache.org/examples/zh/index.html">Echarts实例</a></p>
<h3 id="如何保证窗口变化时Echarts大小也随之调整？">如何保证窗口变化时Echarts大小也随之调整？</h3>
<h4 id="当前页面只有一个图表">当前页面只有一个图表</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line">var option=&#123;title:&#123;text:&#x27;ECharts 入门示例&#x27;&#125;,tooltip:&#123;&#125;,legend:&#123;data:[&#x27;销量&#x27;]&#125;,xAxis:&#123;data:[&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]&#125;,yAxis:&#123;&#125;,series:[&#123;name:&#x27;销量&#x27;,type:&#x27;bar&#x27;,data:[5,20,36,10,10,20]&#125;]&#125;;</span><br><span class="line">myChart.setOption(option);</span><br><span class="line">window.onresize = myChart.resize;</span><br></pre></td></tr></table></figure>
<h4 id="当前页面有多个图表">当前页面有多个图表</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line">var myChartA = echarts.init(document.getElementById(&#x27;mainA&#x27;));</span><br><span class="line">var myChartB = echarts.init(document.getElementById(&#x27;mainB&#x27;));</span><br><span class="line">// 指定图表的配置项和数据</span><br><span class="line">var option=&#123;title:&#123;text:&#x27;ECharts 入门示例&#x27;&#125;,tooltip:&#123;&#125;,legend:&#123;data:[&#x27;销量&#x27;]&#125;,xAxis:&#123;data:[&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]&#125;,yAxis:&#123;&#125;,series:[&#123;name:&#x27;销量&#x27;,type:&#x27;bar&#x27;,data:[5,20,36,10,10,20]&#125;]&#125;;</span><br><span class="line">// 使用刚指定的配置项和数据显示图表。</span><br><span class="line">myChart.setOption(option);</span><br><span class="line">myChartA.setOption(option);</span><br><span class="line">myChartB.setOption(option);</span><br><span class="line">window.addEventListener(&quot;resize&quot;,function ()&#123;</span><br><span class="line">    myChart.resize();</span><br><span class="line">    myChartA.resize();</span><br><span class="line">    myChartB.resize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考文章：<br>
<a href="https://www.cnblogs.com/aknife/p/12850258.html#:~:text=echarts%E5%A4%9A%E4%B8%AA%E5%9B%BE%E8%A1%A8%E5%A4%A7%E5%B0%8F%E9%9A%8F%E5%B1%8F%E5%B9%95%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%94%B9%E5%8F%98%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8CEcharts%20%E5%A4%9A%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%EF%BC%8Cecharts%E9%9A%8F%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96%EF%BC%9B%20%E5%BD%93%E9%A1%B5%E9%9D%A2%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9B%BE%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E7%94%A8,window.onresize%20%3D%20myChart.resize%20%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">Echarts实现随窗口变化而调整</a></p>
<h4 id="如何使每次刷新页面，会使图表展现不同的颜色？">如何使每次刷新页面，会使图表展现不同的颜色？</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function getColor(num) &#123;</span><br><span class="line">  var colorList = [];</span><br><span class="line">  for (var i = 0; i &lt; num; i++) &#123;</span><br><span class="line">    colorList.push(randColor());</span><br><span class="line">  &#125;</span><br><span class="line">  return colorList;</span><br><span class="line">&#125;</span><br><span class="line">function showdetails(i)&#123;</span><br><span class="line">  var elementById = document.getElementById(i);</span><br><span class="line">  alert(elementById.getAttribute(&quot;value&quot;));</span><br><span class="line">&#125;</span><br><span class="line">function randColor() &#123;</span><br><span class="line">  return &#x27;#&#x27; +</span><br><span class="line">          (function (color) &#123;</span><br><span class="line">            return (color += &#x27;0123456789abcdef&#x27;[Math.floor(Math.random() * 16)])</span><br><span class="line">            &amp;&amp; (color.length == 6) ? color : arguments.callee(color);</span><br><span class="line">          &#125;)(&#x27;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何保证输入框中不能修改其内容数据？">如何保证输入框中不能修改其内容数据？</h4>
<p>添加代码readonly=&quot;readonly</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">tdBodys += `<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;$&#123;i&#125;x&quot;</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;i&#125;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">$&#123;isReachnodes&#125;</span> <span class="attr">style</span>=<span class="string">&quot;border: none;text-align: center;color: #444444;color: #444444&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;readonly&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>`;</span><br></pre></td></tr></table></figure>
<h4 id="如何通过input中id获得其对应的value值？">如何通过input中id获得其对应的value值？</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">tdBodys += `<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;$&#123;i&#125;x&quot;</span> <span class="attr">id</span>=<span class="string">&quot;$&#123;i&#125;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">$&#123;isReachnodes&#125;</span> <span class="attr">style</span>=<span class="string">&quot;border: none;text-align: center;color: #444444;color: #444444&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;readonly&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>`;   </span><br><span class="line">tdBodys += `<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showdetails($&#123;i&#125;)&quot;</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>`;</span><br><span class="line">  </span><br><span class="line">function showdetails(i)&#123;</span><br><span class="line">  var elementById = document.getElementById(i);</span><br><span class="line">  alert(elementById.getAttribute(&quot;value&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2023/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="机器学习">机器学习</h2>
<span id="more"></span>
<h3 id="支持向量机的对偶问题">支持向量机的对偶问题</h3>
<p>[支持向量机的对偶问题](<a href="https://blog.csdn.net/randompeople/article/details/92083294">(7条消息) 支持向量机（SVM）中的对偶问题_予亭的博客-CSDN博客_支持向量机对偶问题</a>)</p>
<p>[凸集、凸函数、凸优化问题，线性规划，二次规划](<a href="https://zhuanlan.zhihu.com/p/263126963">凸集，凸函数，凸优化问题，线性规划，二次规划，二次约束二次规划，半正定规划 - 知乎 (zhihu.com)</a>)</p>
<p><strong>凸优化</strong>：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>在最小化（最大化）的要求下</p>
</li>
<li class="lvl-3">
<p>目标函数是一个凸函数（凹函数）</p>
</li>
<li class="lvl-3">
<p>约束条件所形成的可行域集合是一个凸集</p>
</li>
</ol>
</blockquote>
<p>仿射函数</p>
<p>$F (x) = A x + b$</p>
<h3 id="支持向量机中支撑向量">支持向量机中支撑向量</h3>
<pre><code>[支撑向量]([SVM系列第五讲--支撑向量 - 简书 (jianshu.com)](https://www.jianshu.com/p/a2c9ab800946))
</code></pre>
<img title src="file:///C:/Users/田晓滨/AppData/Roaming/marktext/images/2022-11-17-21-08-35-image.png" alt width="292" data-align="center">
<h3 id="过拟合和欠拟合">过拟合和欠拟合</h3>
<pre><code>&gt; 过拟合：当学习器把训练样本**学的“太好”了的**时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降，这种现象称为过拟合。
&gt; 
&gt; 欠拟合：欠拟合是指对训练样本的一般性质尚未学好。在训练集及测试集上的表现都不好
</code></pre>
<p>[过拟合和欠拟合](<a href="https://blog.csdn.net/qq_42012732/article/details/107318550">(7条消息) 过拟合与欠拟合_Minouio的博客-CSDN博客</a>)</p>
<h3 id="决策树节点划分">决策树节点划分</h3>
<pre><code>&gt; &lt;font color=Red&gt;ID3使用最大信息熵增益&lt;/font&gt;
&gt; 
&gt; 信息熵Entropy或Info。熵反应了物体内部的混乱程度，而信息熵反应了不同类的样本的占比，也就是节点的纯度。信息熵越大，说明样本的分布节点的纯度越低，信息量越少；相反，信息熵越小，说明样本的角度越高，信息量越大。
&gt; 
&gt; **根据信息熵的含义，我们知道我们要选择能使节点内部纯度高、也就是信息熵最小的特征作为划分依据，我们就计算以某个特征划分自己之后当前节点划分之后各个节点的信息熵之和，并且要是这个和与当前节点划分前的信息熵减小的尽可能多。而这个差也就是信息增益**
&gt; 
&gt; $\color&#123;red&#125;&#123;C4.5使用信息增益比率&#125;$
&gt; 
&gt; 增益比率在信息熵增益的基础上除以每个划分的信息熵(Split Information)，从而消除这种有大量的子节点、但每个子节点的样本数量很少的情况的影响。
&gt; 
&gt; $\color&#123;green&#125;&#123;CART使用基尼指数&#125;$
&gt; 
&gt; CART使用基尼系数（GINI）作为划分依据。选择GINI系数最小的特征作为当前的分割数据的特征。基尼系数反映了从样本集中随机抽取两个样本，其类别不一样的概率。基尼系数越大，也就意味着从样本集中随机抽两个样本的类别不相同的概率越大，也就是样本的纯度越小，即对应这信息熵越大。
</code></pre>
<p>[信息熵、不纯度](<a href="https://blog.csdn.net/qq_42442369/article/details/86625591">(7条消息) 决策树算法笔记整理1 - 如何划分？（信息熵，不纯度及信息增益）_sevieryang的博客-CSDN博客</a>)</p>
<h3 id="决策树策略">决策树策略</h3>
<pre><code>&gt; 类别非纯度、**梯度下降**、**信息增益率**、**基尼指数**
</code></pre>
<h3 id="集成学习中集分类器如何选择使其效率更好">集成学习中集分类器如何选择使其效率更好</h3>
<pre><code>&gt; 在集成学习中，算法不要求每个学习器性能最好，但是期望它们对问题具有不同的看法，即**分类器多样且差异大**
</code></pre>
<p>[分类器的选择](<a href="https://zhuanlan.zhihu.com/p/105038453">经典机器学习系列之【集成学习】 - 知乎 (zhihu.com)</a>)</p>
<h3 id="集成学习中每个集分类器的正确率最低要求为50">集成学习中每个集分类器的正确率最低要求为50%</h3>
<pre><code>&gt; 每个基分类器的错误率都应当低于0.5，否则集成的结果反而会提高错误率。
&gt; 
&gt; 每个基分类器应该尽可能相互独立，这是因为如果每个基分类器分类结果差不多，则集成后的分类器整体和单个分类器做出的决策实际上没有什么差异。
</code></pre>
<p>[集成学习前提](<a href="https://blog.csdn.net/jerr__y/article/details/52955148">(7条消息) 采用集成学习算法提高分类器的准确性_永永夜的博客-CSDN博客</a>)</p>
<h3 id="Bagging学习特点">Bagging学习特点</h3>
<pre><code>&gt; 构造训练集采用Bootstrap方式
&gt; 
&gt; 随机有放回采样，每轮训练样本权重相同
&gt; 
&gt; 分类器可以并行训练
&gt; 
&gt; 预测权重相等
</code></pre>
<h3 id="Boosting学习特点">Boosting学习特点</h3>
<pre><code>&gt; 构造训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整
&gt; 
&gt; 根据错误率不断调整样例的权值，错误率越大则权重越大
&gt; 
&gt; 每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重
&gt; 
&gt; 各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果
</code></pre>
<p>[Bagging和Boosting](<a href="https://zhuanlan.zhihu.com/p/37730184">从0开始机器学习-Bagging和Boosting - 知乎 (zhihu.com)</a>)</p>
<h3 id="随机森林方法">随机森林方法</h3>
<pre><code>&gt; 随机森林算法（Random Forest简称RF）是Bagging算法的进阶。其优化：
&gt; 
&gt; Bagging的基学习器不一定是同质的，也不一定是决策树；但RF以CART为基学习器。
&gt; 
&gt; RF在训练过程中，引入了随机特征选择。RF在Bagging的数据样本扰动的基础上，增加了输入特征扰动，提高了模型的泛化能力。具体来说，传统决策树在选择划分特征时，在当前结点的特征集合中选择一个最优划分特征；而在RF中，是对基决策树的每个结点，先从该结点的特征集合中随机选择一个含有个特征的子集，然后再从该子集选择最优划分特征。越小，模型越健壮，同时对训练集的拟合程度会变差，也就是说，越小，模型方差越小，偏差越大。
</code></pre>
<h3 id="软间隔SVM的阈值趋于无穷">软间隔SVM的阈值趋于无穷</h3>
<pre><code>&gt;  软间隔：放宽SVM的限制，可以允许存在一些误分类的点
&gt; 
&gt; 即C无穷大，在如此高的误分类惩罚下，不会存在软间隔分类超平面，因为一点错误都不可能发生。
&gt; 
&gt; 代价参数的大小决定了SVM能允许的误分类程度。
&gt; C的值小：优化的目标是得到一个尽可能光滑的决策平面。
&gt; C的值大：模型只允许出现很小数量的误分类点。
&gt; 它可以简单的看做是对误分类的惩罚。
</code></pre>
<p>[SVM测试](<a href="https://cloud.tencent.com/developer/article/1169308#:~:text=1%20%E5%8F%AA%E8%A6%81%E6%9C%80%E4%BD%B3%E5%88%86%E7%B1%BB%E8%B6%85%E5%B9%B3%E9%9D%A2%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%AE%83%E5%B0%B1%E8%83%BD%E5%B0%86%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E6%AD%A3%E7%A1%AE%E5%88%86%E7%B1%BB%202,%E8%BD%AF%E9%97%B4%E9%9A%94SVM%E5%88%86%E7%B1%BB%E5%99%A8%E5%B0%86%E6%AD%A3%E7%A1%AE%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%203%20%E4%BA%8C%E8%80%85%E9%83%BD%E4%B8%8D%E5%AF%B9">独家 | 25道SVM题目，测一测你的基础如何?（附资源） - 腾讯云开发者社区-腾讯云 (tencent.com)</a>)</p>
<h3 id="回归问题和分类问题的区别">回归问题和分类问题的区别</h3>
<pre><code>&gt; 连续即回归，离散即分类
</code></pre>
<img title src="file:///C:/Users/田晓滨/AppData/Roaming/marktext/images/2022-11-17-23-10-14-image.png" alt width="556" data-align="center">
<p>[分类和回归](<a href="https://www.zhihu.com/question/21329754">(30 封私信 / 80 条消息) 分类与回归区别是什么？ - 知乎 (zhihu.com)</a>)</p>
<h3 id="最小二乘回归方法的等效回归方法">最小二乘回归方法的等效回归方法</h3>
<pre><code>&gt; 最小二乘法是在寻找观测数据与回归超平面之间的误差距离最小的参数。最大似然估计是最大化观测数据发生的概率
</code></pre>
<p>[最小二乘回归和最大似然回归](<a href="https://zhuanlan.zhihu.com/p/143416436">最大似然估计：从概率角度理解线性回归的优化目标 - 知乎 (zhihu.com)</a>)</p>
<h3 id="正则化的回归分析">正则化的回归分析</h3>
<blockquote>
<p>当数据量少，特征也少的时候，我们训练的模型是<strong>欠拟合</strong>，这时候我们会通过<strong>交叉验证</strong>来弥补。<br>
当数据量少，特征非常多的时候，容易出现<strong>过拟合</strong>，这时要通过<strong>正则化</strong>调整。</p>
</blockquote>
<p>[正则化线性回归](<a href="https://blog.csdn.net/qq_23371241/article/details/78373888">(7条消息) 正则化(线性回归)_小星爷的博客-CSDN博客</a>)</p>
<h3 id="关联分析">关联分析</h3>
<h3 id="混合高斯聚类">混合高斯聚类</h3>
<pre><code>&gt; $\color&#123;red&#125;&#123;EM算法&#125;$：期望最大化算法，被用来学习高斯混合模型（Gaussian mixture model，简称GMM）的参数；隐式马尔科夫算法（HMM）、LDA主题模型的变分推断等等。
&gt; 
&gt; EM算法是一种迭代优化策略，由于它的计算方法中每一次迭代都分两步，其中一个为**期望步（E步）**，另一个为**极大步（M步）**，所以算法被称为EM算法。EM算法受到缺失思想影响，最初是为了**解决数据缺失情况**下的参数估计问题，其算法基础和收敛有效性等问题在Dempster、Laird和Rubin三人于1977年所做的文章《Maximum likelihood from incomplete data via the EM algorithm》中给出了详细的阐述。其基本思想是：**首先根据己经给出的观测数据，估计出模型参数的值；然后再依据上一步估计出的参数值估计缺失数据的值，再根据估计出的缺失数据加上之前己经观测到的数据重新再对参数值进行估计，然后反复迭代，直至最后收敛，迭代结束**。

[混合高斯聚类理解]([(7条消息) 【机器学习笔记】通俗易懂解释高斯混合聚类原理_lotusng的博客-CSDN博客](https://blog.csdn.net/lotusng/article/details/79990724))
</code></pre>
<p>[EM算法](<a href="https://zhuanlan.zhihu.com/p/40991784">EM算法详解 - 知乎 (zhihu.com)</a>)</p>
<h3 id="主成分分析是一种降维方法">主成分分析是一种降维方法</h3>
<h3 id="PCA做降维处理时，优先处理-中心化样本的协方差矩阵的最大特征值对应特征向量">PCA做降维处理时，优先处理 中心化样本的协方差矩阵的最大特征值对应特征向量</h3>
<pre><code>&gt; $\color&#123;red&#125;&#123;PCA&#125;$(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是**从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的**。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。

&gt; [PCA]([主成分分析（PCA）原理详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37777074))
</code></pre>
<h3 id="过拟合：训练样本测试误差小，测试样本正确识别率很低">过拟合：训练样本测试误差小，测试样本正确识别率很低</h3>
<h3 id="马尔科夫链">马尔科夫链</h3>
<h3 id="pass">pass</h3>
<h3 id="pass-2">pass</h3>
<h3 id="pass-3">pass</h3>
<h3 id="梯度下降算法正确步骤">梯度下降算法正确步骤</h3>
<pre><code>&gt; 原理：**寻找损失函数的最低点**，就像我们在山谷里行走，希望找到山谷里最低的地方。那么如何寻找损失函数的最低点呢？在这里，我们使用了微积分里导数，通过求出函数导数的值，从而找到函数下降的方向或者是最低点（极值点）

&gt; 步骤：
&gt; 
&gt; 1. 初始化随即权重和偏差
&gt; 2. 将输入传入网络，得到输出值
&gt; 3. 计算预测值于真实值之间的误差
&gt; 4. 对产生误差的神经元，改变相应权重值以减小误差
&gt; 5. 迭代更新，直到找到最佳权重
&gt; 
&gt;     $w_&#123;i+1&#125;=w_&#123;i&#125;-\alpha*\frac&#123;L&#125;&#123;dw_i&#125;$
&gt; 
&gt;     $b_&#123;i+1&#125;=b_i-\alpha*\frac&#123;dL&#125;&#123;db_i&#125;$
</code></pre>
<p>[markdown数学公式总结](<a href="https://blog.csdn.net/jyfu2_12/article/details/79207643#:~:text=Markdown%20%E6%95%B0%E5%AD%A6%E8%AF%AD%E6%B3%95%201.%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%201.%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%20%E4%BB%A5%20%24%20%E5%BC%80%E5%A4%B4%EF%BC%8C%E4%BB%A5,%24%20%E7%BB%93%E5%B0%BE%E3%80%82%20eg%3A%20aba%5Ebab%20%24a%5Eb%24%202.%E5%9D%97%E7%BA%A7%E5%85%AC%E5%BC%8F%E2%80%93%E8%A1%8C%E9%97%B4%E5%85%AC%E5%BC%8F%20%E4%BB%A5">(8条消息) markdown最全数学公式速查_xkgjfl的博客-CSDN博客</a>)</p>
<p>[markdown常见公式](<a href="https://blog.csdn.net/linshen1213/article/details/115330264?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115330264-blog-79207643.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115330264-blog-79207643.pc_relevant_recovery_v2&amp;utm_relevant_index=1">(8条消息) 一、markdown 常见公式_林重言的博客-CSDN博客</a>)</p>
<p>[梯度下降算法](<a href="https://cn.bing.com/search?q=%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95&amp;sc=10-6&amp;sk=&amp;cvid=08A6A8953DF24DDAA898BBE01BC20C51&amp;ghsh=0&amp;ghacc=0&amp;ghpl=">梯度下降算法 - 搜索 (bing.com)</a>)</p>
<h3 id="岭回归">岭回归</h3>
<pre><code>&gt; $\color &#123;red&#125; &#123;方差&#125;$： 都是围着数据中心的，方差越大则表示距离数据中心分布的越分散，越小说明越近越集中
&gt; 
&gt; $\color&#123;red&#125;&#123;偏差&#125;$： 偏离数据中心， 偏差越大，说明整个数据距离中心越远，偏差越小，说明距离数据中心越近。
&gt; 
&gt; 这两者的关系通常是**矛盾**的，降低偏差会提高方差，降低方差会提高偏差。所有一个好的模型就是对这点的一个平衡。 

&gt; $\color&#123;red&#125;&#123;岭回归&#125;$ :针对高方差，即过拟合的模型，解决办法之一就是对模型进行正则化：限制参数大小。当线性回归过拟合时，权重系数wj就会非常的大，岭回归就是要解决这样的问题。岭回归可以理解为在线性回归的损失函数的基础上，加,入一个L2正则项，来限制W不要过大。其中λ&gt;0，通过确定λ的值可以使得模型在偏差和方差之间达到平衡，**随着λ的增大，模型的方差减小，偏差增大**。
</code></pre>
<img title src="file:///C:/Users/田晓滨/AppData/Roaming/marktext/images/2022-11-19-12-00-31-image.png" alt data-align="center" width="324">
<p>[岭回归](<a href="https://www.cnblogs.com/hechangchun/p/15194557.html#:~:text=%E5%B2%AD%E5%9B%9E%E5%BD%92%EF%BC%88Ridge,Regression%EF%BC%89%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E5%8A%A0%2C%E5%85%A5%E4%B8%80%E4%B8%AAL2%E6%AD%A3%E5%88%99%E9%A1%B9%EF%BC%8C%E6%9D%A5%E9%99%90%E5%88%B6W%E4%B8%8D%E8%A6%81%E8%BF%87%E5%A4%A7%E3%80%82%20%E5%85%B6%E4%B8%AD%CE%BB%3E0%EF%BC%8C%E9%80%9A%E8%BF%87%E7%A1%AE%E5%AE%9A%CE%BB%E7%9A%84%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E5%BE%97%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE%E4%B9%8B%E9%97%B4%E8%BE%BE%E5%88%B0%E5%B9%B3%E8%A1%A1%EF%BC%8C%E9%9A%8F%E7%9D%80%CE%BB%E7%9A%84%E5%A2%9E%E5%A4%A7%EF%BC%8C%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B9%E5%B7%AE%E5%87%8F%E5%B0%8F%EF%BC%8C%E5%81%8F%E5%B7%AE%E5%A2%9E%E5%A4%A7%E3%80%82">学习笔记233—岭回归和Lasso回归区别 - 何弈 - 博客园 (cnblogs.com)</a>)</p>
<h3 id="增加模型的欠拟合风险">增加模型的欠拟合风险</h3>
<pre><code>&gt; $\color&#123;red&#125;&#123;过拟合&#125;$
&gt; 
&gt; 原因：
&gt; 
&gt; 训练数据中**噪音干扰过大**，使得学习器认为部分噪音是特征从而扰乱学习规则。
&gt; 
&gt; 建模**样本选取有误**，例如训练数据太少，抽样方法错误，样本label错误等，导致样本不能代表整体。
&gt; 
&gt; **模型不合理**，或假设成立的条件与实际不符。
&gt; 
&gt; **特征维度/参数太多**，导致模型复杂度太高。  
&gt; 
&gt;  解决方法：
&gt; 
&gt; **从数据源头获取更多数据**
&gt; 
&gt; **根据当前数据集估计数据分布参数，使用该分布产生更多数据**。这个方法一般不用，因为估计参数分布的过程也会带入抽样误差。
&gt; 
&gt; **数据增强**（Data Augmentation）:通过一定规则扩充数据。如物体在图像中的位置、姿态、尺度、整体图片明暗度等都不会影响分类结果。我们可以通过图像平移、反转、缩放、切割等手段将数据库成倍扩充
&gt; 
&gt; **保留验证集**
&gt; 
&gt; **获取额外数据进行交叉验证**
&gt; 
&gt; **降低模型复杂度**
&gt; a. 对于神经网络：减少网络的层数、神经元个数等均可以限制网络的拟合能力。dropout，在向前传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型的泛化性更强，因为它不会太依赖某些局部的特征。。
&gt; b. 对于决策树：限制树深，剪枝，限制叶节点数量。
&gt; c. 增大分割平面间隔
&gt; 
&gt; **特征选择、特征降维**
&gt; 
&gt; **early stopping**
&gt; 
&gt; **正则化**（限制权值weight-decay）：将权值的大小作为惩罚项加入到损失函数里。
&gt; 
&gt; **增加噪声**
&gt; **ensemble**
&gt; 
&gt; $\color&#123;red&#125;&#123;欠拟合&#125;$
&gt; 
&gt; 原因：
&gt; 
&gt; **模型复杂度过低**
&gt; **特征量过少**
&gt; 
&gt; 解决方法：
&gt; 
&gt; **增加特征数**；
&gt; 当特征不足或者现有特征与样本标签的相关性不强时，模型易出现欠拟合。
&gt; 可以通过挖掘上下文特征，ID类特征，组合特征等新的特征，可以取得较好的效果。这属于特征工程相关的内容，如因子分解机，梯度提升决策树，deep_crossing都可以丰富特征。
&gt; 
&gt; **增加模型复杂度**；
&gt; 模型简单时其表达能力较差，容易导致欠拟合，因此可以适当地增加模型复杂度，使模型拥有更强的拟合能力。
&gt; 如线性模型中添加高次项，神经网络中增加网络层数或神经元个数。尝试非线性模型，比如核SVM 、决策树、DNN等模型。
&gt; 
&gt; **减小正则化系数**。
&gt; 正则化是用于防止过拟合的，但是当出现欠拟合时，就有必要针对性地减小正则化系数。
</code></pre>
<p>[欠拟合和过拟合原因+解决方法](<a href="https://blog.csdn.net/qq_42012732/article/details/107318550">(8条消息) 过拟合与欠拟合_Minouio的博客-CSDN博客</a>)</p>
<h3 id="Bagging每轮训练的样本权重相同，而Bootsting则根据单个分类器的正确率选择权重">Bagging每轮训练的样本权重相同，而Bootsting则根据单个分类器的正确率选择权重</h3>
<pre><code>EM算法和梯度下降都会陷于局部极小值

梯度下降也可用于求混合高斯模型的参数(一般不适用)     
</code></pre>
<h3 id="随机森林模型过拟合与决策树深度、叶节点数有关">随机森林模型过拟合与决策树<strong>深度、叶节点数</strong>有关</h3>
<h3 id="pass-4">pass</h3>
<h3 id="pass-5">pass</h3>
<h3 id="K-means算法">K-means算法</h3>
<pre><code>&gt; K均值聚类是最基础常用的聚类算法，它的基本思想是，**通过迭代寻找K个簇的一种划分方案，使得聚类结果对应的损失函数最小**。
&gt; 
&gt; KMenas的优点：
&gt; 
&gt; - 高效可伸缩，计算复杂度 为接近于线性（N是数据量，K是聚类总数，t是迭代轮数）。
&gt; - 收敛速度快，原理相对通俗易懂，可解释性强。
&gt; 
&gt; KMeans也有一些明显的缺点：
&gt; 
&gt; - 受初始值和异常点影响，聚类结果可能不是全局最优而是局部最优。
&gt; - K是超参数，一般需要按经验选择
&gt; - 样本点只能划分到单一的类中 
&gt; 
&gt; 迭代的时间复杂度$\Omicron(n)$ 
&gt; 
&gt; K-means可以使用核函数，就是将数据点都投影到了一个高维的特征空间中（为啥要这么做呢，主要是突显出不同样本中的差异），然后再在这个高维的特征空间中，进行传统的k-means聚类
&gt; 
&gt; K-mean适用于当簇是密集的、球状或团状的，而簇与簇之间区别明显时，使用[k-mean](https://www.zhihu.com/search?q=k-mean&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A980863878%7D)聚类效果很好；在应用[欧式距离](https://www.zhihu.com/search?q=%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A980863878%7D)时，只能找到数据点分布的比较均匀的簇。
</code></pre>
<p>[K-means](<a href="https://zhuanlan.zhihu.com/p/184686598">KMeans聚类算法详解 - 知乎 (zhihu.com)</a>)</p>
<p>[核K-means](<a href="https://www.cnblogs.com/subaiBlog/p/6271315.html#:~:text=%E6%A0%B8k-means%EF%BC%8C%E6%A6%82%E6%8B%AC%E5%9C%B0%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%B0%86%E6%95%B0%E6%8D%AE%E7%82%B9%E9%83%BD%E6%8A%95%E5%BD%B1%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E9%AB%98%E7%BB%B4%E7%9A%84%E7%89%B9%E5%BE%81%E7%A9%BA%E9%97%B4%E4%B8%AD%EF%BC%88%E4%B8%BA%E5%95%A5%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%E5%91%A2%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E7%AA%81%E6%98%BE%E5%87%BA%E4%B8%8D%E5%90%8C%E6%A0%B7%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%AB%98%E7%BB%B4%E7%9A%84%E7%89%B9%E5%BE%81%E7%A9%BA%E9%97%B4%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%BC%A0%E7%BB%9F%E7%9A%84k-means%E8%81%9A%E7%B1%BB%E3%80%82%20%E4%B8%BB%E8%A6%81%E7%9A%84%E6%80%9D%E6%83%B3%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%8C%E6%AF%94%E8%B5%B7%E4%BC%A0%E7%BB%9F%E6%99%AE%E9%80%9A%E7%9A%84k-means%E5%B0%B1%E5%A4%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%AD%A5%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82%20%E6%89%80%E4%BB%A5%E5%AE%83%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B9%9F%E4%B8%8E%E4%BC%A0%E7%BB%9Fk-means%E5%BE%88%E7%9B%B8%E8%BF%91%EF%BC%9A%20%E8%BF%99%E9%87%8C%E6%89%80%E8%A1%A8%E7%A4%BA%E7%9A%84%EF%BC%8C%24a_i%24%E6%98%AF%E5%90%84%E4%B8%AA%E6%A0%B7%E6%9C%AC%E7%82%B9%EF%BC%8C%E8%80%8C%24phi,%28%20%29%24%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%99%E6%98%AF%E8%A1%A8%E7%A4%BA%E5%B0%86%E6%A0%B7%E6%9C%AC%E7%82%B9%E6%98%A0%E5%B0%84%E8%87%B3%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E3%80%82%20%E8%80%8C%E5%85%AC%E5%BC%8F%E4%B8%AD%E7%9A%84%24m_c%24%EF%BC%8C%E5%88%99%E6%98%AF%E6%AF%8F%E4%B8%AA%E7%B0%87%E4%B8%AD%E7%9A%84%E8%B4%A8%E5%BF%83%E3%80%82%20%E8%BF%99%E4%B8%AA%E5%BD%A2%E5%BC%8F%EF%BC%8C%E5%AF%B9%E6%AF%94%E8%B5%B7%E6%99%AE%E9%80%9A%E7%9A%84k-means%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BE%88%E7%9B%B8%E8%BF%91%E5%92%A7%EF%BC%8C%E5%90%8C%E6%A0%B7%E6%98%AF%E6%B1%82%E5%90%84%E4%B8%AA%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%88%E4%BC%A0%E7%BB%9Fk-means%E4%B8%AD%E6%98%AF%E6%A0%B7%E6%9C%AC%E7%82%B9%EF%BC%89%E4%B8%8E%E8%B4%A8%E5%BF%83%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E8%AF%A5%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%88%B0%E4%B8%8D%E5%90%8C%E8%B4%A8%E5%BF%83%E8%B7%9D%E7%A6%BB%EF%BC%8C%E9%80%89%E6%8B%A9%E6%9C%80%E5%B0%8F%E7%9A%84%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E8%B7%9D%E7%A6%BB%E8%AF%A5%E6%A0%B7%E6%9C%AC%E7%82%B9%E6%9C%80%E8%BF%91%EF%BC%89%E7%9A%84%E7%B0%87%E5%BF%83%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%88%86%E9%85%8D%EF%BC%88%E5%B0%86%E8%AF%A5%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%BD%92%E4%B8%BA%E8%BF%99%E4%B8%AA%E7%B0%87%EF%BC%89%E3%80%82">weighted Kernel k-means 加权核k均值算法理解及其实现（一） - 苏白 - 博客园 (cnblogs.com)</a>)</p>
<h3 id="过拟合训练误差小，测试误差大">过拟合训练误差小，测试误差大</h3>
<h3 id="pass-6">pass</h3>
<h3 id="过拟合问题-见P34">过拟合问题 见P34</h3>
<pre><code>&gt; **稀疏**表示的好处在于降低表示复杂度，更直白**的**原因其实就是**减少**系数参数，通过**稀疏**表示，可以充分发挥数据所含有**的**信息，去掉冗余**的**数据信息，达到最大化利用数据。
&gt; 
&gt; 高斯核比线性核更复杂，使复杂度更高，容易导致过拟合问题。
</code></pre>
<p>[高斯核和线性核](<a href="https://blog.csdn.net/weixin_44492824/article/details/122546701">核函数 高斯核函数，线性核函数，多项式核函数_TranSad的博客-CSDN博客</a>)</p>
<h3 id="无监督和监督">无监督和监督</h3>
<h3 id="Bootstrap：Bootstrap法具体是指用原样本自身的数据抽样得出新的样本及统计量">Bootstrap：Bootstrap法具体是指<strong>用原样本自身的数据</strong>抽样得出新的样本及统计量</h3>
<h3 id="Adaboost算法">Adaboost算法</h3>
<pre><code>&gt; $\color&#123;red&#125;&#123;原理&#125;$:是从训练数据中学习出一系列的弱分类器，并将弱分类器组合成一个强分类器
&gt; 
&gt; $\color&#123;red&#125;&#123;提升树&#125;$：采用**加法**模型（基函数的线性组合）与**前向分布**算法，同时以决策树为基函数的提升方法。对于分类问题而言是二叉分类树，但对于回归问题而言是二叉回归树
</code></pre>
<h3 id="HMM">HMM</h3>
<h3 id="会考虑向量的方向的距离">会考虑向量的方向的距离</h3>
<pre><code>&gt; Jaccard距离：杰卡德距离

[四种距离]([欧氏距离，曼哈顿距离，余弦距离，汉明距离_南极洲闲人的博客-CSDN博客_汉明距离和欧式距离](https://blog.csdn.net/weixin_45965358/article/details/112992351))

[机器学习中的距离]([机器学习中的数学——距离定义（十三）：杰卡德距离（Jaccard Distance）和杰卡德相似系数（Jaccard Similarity Coefficient）_von Neumann的博客-CSDN博客](https://blog.csdn.net/hy592070616/article/details/122279515))
</code></pre>
<h3 id="pass-7">pass</h3>
<h3 id="pass-8">pass</h3>
<h3 id="pass-9">pass</h3>
<h3 id="pass-10">pass</h3>
<h3 id="不知道数据所带标签时，可以使用聚类技术促使带同类标签的数据与带其他标签的数据相分离">不知道数据所带标签时，可以使用<strong>聚类</strong>技术促使带同类标签的数据与带其他标签的数据相分离</h3>
<pre><code>&gt; 聚类是无监督学习
&gt; 
&gt; 回归和分类是监督学习
</code></pre>
<h3 id="矩阵计算pass">矩阵计算pass</h3>
<h3 id="最大似然估计不考虑先验分布"><strong>最大似然估计</strong>不考虑先验分布</h3>
<pre><code>&gt; 贝叶斯公式：$P(A|B)= \frac&#123;P(B|A)*P(A)&#125;&#123;P(B)&#125;$
</code></pre>
<p>[最大似然估计](<a href="https://zhuanlan.zhihu.com/p/55791843">参数估计(二).最大似然估计 - 知乎 (zhihu.com)</a>)</p>
<h3 id="pass-11">pass</h3>
<h3 id="pass-12">pass</h3>
<h3 id="pass-13">pass</h3>
<h3 id="pass-14">pass</h3>
<h3 id="pass-15">pass</h3>
<h3 id="pass-16">pass</h3>
<h3 id="生成式模型和判别式模型">生成式模型和判别式模型</h3>
<pre><code>![](C:\Users\田晓滨\AppData\Roaming\marktext\images\2022-11-21-23-29-56-image.png)
</code></pre>
<p>[生成式模型和判别式模型](<a href="https://zhuanlan.zhihu.com/p/74586507">机器学习中的判别式模型和生成式模型 - 知乎 (zhihu.com)</a>)</p>
<h3 id="pass-17">pass</h3>
<h3 id="pass-18">pass</h3>
<h3 id="条件随机场（conditional-random-field-CRF）是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型（即判别模型），其特点是假设输出随机变量构成马尔可夫随机场。条件随机场可以用于不同的预测问题，">条件随机场（conditional random field,CRF）是给定一组输入随机变量条件下另一组输出随机变量的<strong>条件概率分布模型（即判别模型）</strong>，其特点是假设<strong>输出随机变量构成马尔可夫随机场</strong>。条件随机场可以用于不同的预测问题，</h3>
<h3 id="KNN用于样本较少但典型性好的情况">KNN用于样本较少但典型性好的情况</h3>
<h3 id="过拟合在监督学习和无监督学习中都会发生。">过拟合在监督学习和无监督学习中都会发生。</h3>
<h3 id="大数据集上训练决策树，通过减少树的深度可以缩短时间">大数据集上训练决策树，通过减少树的深度可以缩短时间</h3>
<h3 id="K-折交叉验证">K 折交叉验证</h3>
<pre><code>[K 折交叉验证]([k折交叉验证_tianguiyuyu的博客-CSDN博客](https://blog.csdn.net/tianguiyuyu/article/details/80697223))
</code></pre>
<h3 id="pass-19">pass</h3>
<h3 id="贝叶斯分类器参数估计">贝叶斯分类器参数估计</h3>
<pre><code>&gt; 最大间隔用于支持向量机SVM中

[贝叶斯分类器]([贝叶斯分类器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/149774236))
</code></pre>
<h3 id="机器学习可解决的问题：分类、聚类和回归">机器学习可解决的问题：分类、聚类和回归</h3>
<h3 id="KNN算法缺点">KNN算法缺点</h3>
<pre><code>&gt; KNN有着非常明显的优点和缺点：
&gt; 
&gt; 优点：精度高、对异常值不敏感、无数据输入假定
&gt; 
&gt; 缺点：计算复杂度高、空间复杂度高
</code></pre>
<h3 id="计算题">计算题</h3>
<ol start="13">
<li class="lvl-4">
<p>K-means</p>
</li>
<li class="lvl-4">
<p>自底向上层次聚类</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络">计算机网络</h2>
<span id="more"></span>
<h3 id="瓶颈带宽、链路带宽、可用带宽">瓶颈带宽、链路带宽、可用带宽</h3>
<blockquote>
<p>瓶颈带宽：源节点与目的节点之间处理能力最低的链路所能提供的最大数据传输速率</p>
<p>链路带宽：链路上最大数据传输速率</p>
<p>可用带宽：网络在不影响其他业务流的情况下，所能给一个业务流提供的最大数据传输速率</p>
</blockquote>
<h3 id="网络加载慢">网络加载慢</h3>
<blockquote>
<p>服务器负载大</p>
<p>网络拥塞</p>
<p>服务器带宽不足</p>
</blockquote>
<h3 id="TCP-IP体系结构对移动性支持不好">TCP/IP体系结构对移动性支持不好</h3>
<blockquote>
<p>$\color{red}{原因}$</p>
<ol>
<li class="lvl-3">
<p>IP地址既表示位置又表示身份，移动时位置发生改变，身份不会改变。</p>
</li>
<li class="lvl-3">
<p>复杂的网络协议和系统无法支持快速组网</p>
</li>
<li class="lvl-3">
<p>不支持地址和身份的动态绑定，移动过程中会切换地址</p>
</li>
</ol>
<p>$\color{red}{解决方案}$</p>
<ol>
<li class="lvl-3">
<p>Mobile TP</p>
<ol>
<li class="lvl-6">
<p>移动主机存在一个永久的IP地址identifier，移动时网络前缀不变</p>
</li>
<li class="lvl-6">
<p>主机移动时，分配新的IP地址locator</p>
</li>
<li class="lvl-6">
<p>两个地址共存，locator负责数据接收，identifier负责解复用数据</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>连接和IP地址解绑定</p>
<ol>
<li class="lvl-6">
<p>当IP地址发生改变时，移动一方通告对方自己新的地址</p>
</li>
<li class="lvl-6">
<p>两端应用连接断开</p>
</li>
</ol>
</li>
<li class="lvl-3">
<p>使用NDN机制</p>
</li>
</ol>
</blockquote>
<h3 id="超时重传">超时重传</h3>
<blockquote>
<p>$\color{red}{概念}$</p>
<p>超时重传是TCP保证可靠性传输的重要机制。当发送端发送一个报文，TCP会为其保留一个副本，设定一个计时器并等待确认信息，当计时器过期并且发送端发送的报文中数据未获得确认时，TCP会重传该报文，直到成功为止。</p>
</blockquote>
<p>输入网址，跳转网页过程</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>DNS解析网址对应的IP地址</p>
</li>
<li class="lvl-2">
<p>构建HTTP请求，封装TCP/IP数据包</p>
</li>
<li class="lvl-2">
<p>根据IP地址查找网关和下一跳IP地址</p>
</li>
<li class="lvl-2">
<p>根据下一跳IP地址寻找下一跳MAC地址</p>
</li>
<li class="lvl-2">
<p>将数据包发送到网关</p>
</li>
<li class="lvl-2">
<p>根据路由寻址抵达网页服务器</p>
</li>
<li class="lvl-2">
<p>服务器解析请求，返回指定的页面</p>
</li>
</ul>
</blockquote>
<p>下图是 OpenFlow 局域网络拓扑，S1 的流表包含一条转发规则，Controller 持有全局网络的拓扑信息，请描述 Packet 1 从 C1 到 H2 的转发过程，包含流表查询、流表安装流程以及具体的流表转发规则。</p>
<p><img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C%E7%94%B0%E6%99%93%E6%BB%A8%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-11-23-14-58-18-image.png" alt></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>Packet1从C1的唯一端口转发到S1中去</p>
</li>
<li class="lvl-3">
<p>到达S1，查S1流表，发现无匹配项。将该数据包缓存，查询控制器Controller</p>
</li>
<li class="lvl-3">
<p>控制器下发规则到S1，内容为&quot;DstIP=H2,Output=2&quot;</p>
</li>
<li class="lvl-3">
<p>S1按照规则从S1的port2转发到S2</p>
</li>
<li class="lvl-3">
<p>到达S2，查S2流表，发现无匹配项。将该数据包缓存，查询控制器Controller</p>
</li>
<li class="lvl-3">
<p>控制器下发规则到S2，内容为&quot;DstIP=H2,Output=2&quot;</p>
</li>
<li class="lvl-3">
<p>S2按照规则从S2的port2转发到H2</p>
</li>
</ol>
</blockquote>
<h3 id="为什么-RSA-算法是有效的非对称加密算法？什么是数字签名？数字签名认证的过程-是什么">为什么 RSA 算法是有效的非对称加密算法？什么是数字签名？数字签名认证的过程 是什么</h3>
<blockquote>
<p>RSA为有效的非对称加密算法。知道公钥(e,n),，很难知道私钥(d,n)，要想获得私钥，必须知道z=(p-1)*(q-1)，而n=pq，p、q都为大质数，因此除了试错法之外，没有有效的方法将n分解，大数分解难题产生的不对称性也是RSA的理论基础。</p>
<p>$\color{red}{数字签名}$</p>
<p>设计一个可以代替手迹签名的方案。从根本上讲，我们需要一种这样的系统，一方通过该系统可以采用以下方式将已签名的文件发送给接受方：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>接收方要能验证发送方的宣称的身份</p>
</li>
<li class="lvl-2">
<p>发送方不能否认发送的报文</p>
</li>
<li class="lvl-2">
<p>接收方不能伪造数字签名</p>
</li>
</ul>
<p>过程</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>发送方共享公钥</p>
</li>
<li class="lvl-2">
<p>发送方哈希数据</p>
</li>
<li class="lvl-2">
<p>将哈希值用私钥加密</p>
</li>
<li class="lvl-2">
<p>接收方用公钥解密</p>
</li>
<li class="lvl-2">
<p>用哈希将接受数据哈希</p>
</li>
<li class="lvl-2">
<p>将两个哈希值比对，判断是否被篡改</p>
</li>
</ul>
</blockquote>
<h3 id="数据中心网络内部构成一个网络，请从网络管理，协议设计的角度，定性对比数据">数据中心网络内部构成一个网络，请从网络管理，协议设计的角度，定性对比数据</h3>
<p>中心网络和互联网网络。</p>
<table>
<thead>
<tr>
<th>互联网</th>
<th style="text-align:center">数据中心网络</th>
</tr>
</thead>
<tbody>
<tr>
<td>分布式控制/路由</td>
<td style="text-align:center">中心式控制和路由选择</td>
</tr>
<tr>
<td>改变需达成共识</td>
<td style="text-align:center">改变不需要达成共识</td>
</tr>
<tr>
<td>标准传输TCP和UDP</td>
<td style="text-align:center">多种传输协议</td>
</tr>
<tr>
<td>难以测量</td>
<td style="text-align:center">容易测量</td>
</tr>
<tr>
<td>多个自治系统</td>
<td style="text-align:center">一个管理域</td>
</tr>
<tr>
<td>单个最短路径</td>
<td style="text-align:center">源到目的有多条路径</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>华为与Cisco</title>
    <url>/2023/03/26/%E5%8D%8E%E4%B8%BA%E5%92%8C%E6%80%9D%E7%A7%91/</url>
    <content><![CDATA[<h2 id="本次针对华为网络和思科网络不同进行总结">本次针对华为网络和思科网络不同进行总结</h2>
<span id="more"></span>
<hr>
<h3 id="区别">区别</h3>
<h3 id="ACL配置">ACL配置</h3>
<p>这是我遇到的第一个问题<br>
<code>Cisco中ACL默认语句:deny ip any any</code><br>
<code>华为中ACL默认语句:permit ip any any</code></p>
<h3 id="ACL命令">ACL命令</h3>
<h3 id="常用的Cisco网络命令">常用的Cisco网络命令</h3>
<h4 id="路由器口令配置">路由器口令配置</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router&gt;enable </span><br><span class="line">router#config terminal 进入全局配置模式</span><br><span class="line">router(config)#hostname 设置交换机的主机名</span><br><span class="line">router(config)#enable secret xxx 设置特权加密口令</span><br><span class="line">router(config)#enable password xxb 设置特权非密口令</span><br><span class="line">router(config)#line console 0 进入控制台口</span><br><span class="line">router(config-line)#line vty 0 4 进入虚拟终端</span><br><span class="line">router(config-line)#login 要求口令验证</span><br><span class="line">router(config-line)#password xx 设置登录口令xx</span><br><span class="line">router(config)#(Ctrl+z) 返回特权模式</span><br><span class="line">router#exit 返回命令</span><br></pre></td></tr></table></figure>
<h4 id="路由器配置">路由器配置</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router(config)#int s0/0 进入Serail接口</span><br><span class="line">router(config-if)#no shutdown 激活当前接口</span><br><span class="line">router(config-if)#clock rate 64000 设置同步时钟</span><br><span class="line">router(config-if)#ip address 设置IP地址</span><br><span class="line">router(config-if)#ip address second 设置第二个IP</span><br><span class="line">router(config-if)#int f0/0.1 进入子接口</span><br><span class="line">router(config-subif.1)#ip address 设置子接口IP</span><br><span class="line">router(config-subif.1)#encapsulation dot1q 绑定vlan中继协议</span><br><span class="line">router(config)#config-register 0x2142 跳过配置文件</span><br><span class="line">router(config)#config-register 0x2102 正常使用配置文件</span><br><span class="line">router#reload 重新引导</span><br></pre></td></tr></table></figure>
<h4 id="路由器文件操作">路由器文件操作</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router#copy running-config startup-config 保存配置</span><br><span class="line">router#copy running-config tftp 保存配置到tftp</span><br><span class="line">router#copy startup-config tftp 开机配置存到tftp</span><br><span class="line">router#copy tftp flash: 下传文件到flash</span><br><span class="line">router#copy tftp startup-config 下载配置文件</span><br><span class="line">ROM状态：</span><br><span class="line">Ctrl+Break 进入ROM监控状态</span><br><span class="line">rommon&gt;confreg 0x2142 跳过配置文件</span><br><span class="line">rommon&gt;confreg 0x2102 恢复配置文件</span><br><span class="line">rommon&gt;reset 重新引导</span><br><span class="line">rommon&gt;copy xmodem: flash: 从console传输文件</span><br><span class="line">rommon&gt;IP_ADDRESS=10.65.1.2 设置路由器IP</span><br><span class="line">rommon&gt;IP_SUBNET_MASK=255.255.0.0 设置路由器掩码</span><br><span class="line">rommon&gt;TFTP_SERVER=10.65.1.1 指定TFTP服务器IP</span><br><span class="line">rommon&gt;TFTP_FILE=c2600.bin 指定下载的文件</span><br><span class="line">rommon&gt;tftpdnld 从tftp下载</span><br><span class="line">rommon&gt;dir flash: 查看闪存内容</span><br><span class="line">rommon&gt;boot 引导IOS</span><br></pre></td></tr></table></figure>
<h4 id="路由">路由</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 命令格式</span><br><span class="line">router(config)#ip route 2.0.0.0 255.0.0.0 1.1.1.2 静态路由举例</span><br><span class="line">router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2 默认路由举例</span><br><span class="line">router(config)#ip routing 启动路由转发</span><br><span class="line">router(config)#router rip 启动RIP路由协议。</span><br><span class="line">router(config-router)#network 设置发布路由</span><br><span class="line">router(config-router)#negihbor 点对点帧中继用。</span><br></pre></td></tr></table></figure>
<h4 id="帧中继命令">帧中继命令</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router(config)#frame-relay switching 使能帧中继交换</span><br><span class="line">router(config-s0)#encapsulation frame-relay 使能帧中继</span><br><span class="line">router(config-s0)#fram-relay lmi-type cisco 设置管理类型</span><br><span class="line">router(config-s0)#frame-relay intf-type DCE 设置为DCE</span><br><span class="line">router(config-s0)#frame-relay dlci 16</span><br><span class="line">router(config-s0)#frame-relay local-dlci 20 设置虚电路号</span><br><span class="line">router(config-s0)#frame-relay interface-dlci 16</span><br><span class="line">router(config)#log-adjacency-changes 记录邻接变化</span><br><span class="line">router(config)#int s0/0.1 point-to-point 设置子接口点对点</span><br><span class="line">router#show frame pvc 显示永久虚电路</span><br><span class="line">router#show frame map 显示映射</span><br></pre></td></tr></table></figure>
<h4 id="访问控制列表ACL">访问控制列表ACL</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router(config)#access-list permit|deny</span><br><span class="line">router(config)#interface ；default:deny any</span><br><span class="line">router(config-if)#ip access-group in|out ；defaultut</span><br><span class="line">例1</span><br><span class="line">router(config)#access-list 1 deny host 10.65.1.1</span><br><span class="line">router(config)#access-list 1 permit any</span><br><span class="line">router(config)#int f0/0</span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line">例2</span><br><span class="line">router(config)#access-list 4 permit 10.8.1.1</span><br><span class="line">router(config)#access-list 4 deny 10.8.1.0 0.0.0.255</span><br><span class="line">router(config)#access-list 4 permit 10.8.0.0 0.0.255.255</span><br><span class="line">router(config)#access-list 4 deny 10.0.0.0 0.255.255.255</span><br><span class="line">router(config)#access-list 4 permit any</span><br><span class="line">router(config)#int f0/1</span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line">   </span><br><span class="line">access-list permit|deny icmp [type]</span><br><span class="line">access-list permit|deny tcp [port]</span><br><span class="line">例1</span><br><span class="line">router(config)#access-list 101 deny icmp any 10.64.0.2 0.0.0.0 echo</span><br><span class="line">router(config)#access-list 101 permit ip any any</span><br><span class="line">router(config)#int s0/0</span><br><span class="line">router(config-if)#ip access-group 101 in</span><br><span class="line">例2</span><br><span class="line">router(config)#access-list 102 deny tcp any 10.65.0.2 0.0.0.0 eq 80</span><br><span class="line">router(config)#access-list 102 permit ip any any</span><br><span class="line">router(config)#interface s0/1</span><br><span class="line">router(config-if)#ip access-group 102 out</span><br><span class="line">删除访问控制例表</span><br><span class="line">router(config)#no access-list 102</span><br><span class="line">router(config-if)#no ip access-group 101 in</span><br></pre></td></tr></table></figure>
<h4 id="路由器的NAT配置">路由器的NAT配置</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-if)#ip nat inside 当前接口指定为内部接口</span><br><span class="line">Router(config-if)#ip nat outside 当前接口指定为外部接口</span><br><span class="line">Router(config)#ip nat inside source static [p] &lt;私有IP&gt;&lt;公网IP&gt; [port]</span><br><span class="line">Router(config)#ip nat inside source static 10.65.1.2 60.1.1.1</span><br><span class="line">Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80</span><br><span class="line">Router(config)#ip nat pool p1 60.1.1.1 60.1.1.20 255.255.255.0</span><br><span class="line">Router(config)#ip nat inside source list 1 pool p1</span><br><span class="line">Router(config)#ip nat inside destination list 2 pool p2</span><br><span class="line">Router(config)#ip nat inside source list 2 interface s0/0 overload</span><br><span class="line">Router(config)#ip nat pool p2 10.65.1.2 10.65.1.4 255.255.255.0 type rotary</span><br><span class="line">Router#show ip nat translation</span><br><span class="line">rotary 参数是轮流的意思，地址池中的IP轮流与NAT分配的地址匹配。</span><br><span class="line">overload参数用于PAT 将内部IP映射到一个公网IP不同的端口上。</span><br></pre></td></tr></table></figure>
<h4 id="外部网关协议配置">外部网关协议配置</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">routerA(config)#router bgp 100</span><br><span class="line">routerA(config-router)#network 19.0.0.0</span><br><span class="line">routerA(config-router)#neighbor 8.1.1.2 remote-as 200</span><br></pre></td></tr></table></figure>
<h4 id="常用查询">常用查询</h4>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip route ；查看路由表</span><br><span class="line">show vlan     查看vlan配置信息</span><br><span class="line">show interface  查看端口信息</span><br><span class="line">show running-config ；查看当前设备配置</span><br><span class="line">show access-list ；查看访问控制列表配置及匹配数据包数量</span><br><span class="line">show vtp status  查看vtp配置信息 </span><br><span class="line">show running-config  查看当前配置信息</span><br><span class="line">show int f0/0  查看指定端口信息 </span><br><span class="line">dir flash:  查看闪存</span><br><span class="line">show version  查看当前版本信息</span><br><span class="line">show cdp cisco  设备发现协议（可以查看聆接设备）</span><br><span class="line">show cdp traffic  查看接收和发送的cdp包统计信息</span><br><span class="line">show interface f0/1 switchport  查看有关switchport的配置</span><br><span class="line">show cdp neighbors  查看与该设备相邻的cisco设备</span><br><span class="line">show interface stats ；查看交换机所有接口当前接口流量</span><br><span class="line">show version ；查看IOS版本信息及设备正常运行时间</span><br><span class="line">show clock ；查看设备时钟信息</span><br><span class="line">show vtp status ；查看交换机vtp配置模式</span><br><span class="line">show vtp password ；查看交换机vtp配置口令</span><br><span class="line">show env all ；查看设备温度，电源和风扇运转参数及是否报警</span><br><span class="line">show inventory ；调取设备内部板卡出厂模块型号及序列号</span><br><span class="line">show spanning-tree root ；查看交换机生成树根位置</span><br><span class="line">show cdp neighbors ；查看邻接cisco设备基本信息</span><br><span class="line">show cdp neighbors detail ；查看邻接cisco设备详细信息</span><br><span class="line">show interface status ；查看交换机接口状态是否存在errordisable接口disable接口</span><br><span class="line">show interface summary` ；查看交换机所有接口当前接口流量</span><br><span class="line">show interface | i errors|FastEthernet|GigabitEthernet ；查看接口是否存在大量input或output errors包错误</span><br><span class="line">show processes cpu ；查看设备cpu负载</span><br><span class="line">show processes mem ；查看设备mem负载</span><br><span class="line">show logging ；查看本机内部日志记录情况</span><br><span class="line">show firewall ；检查防火墙的工作模式</span><br><span class="line">show conn count ；检查防火墙并发数</span><br><span class="line">show xlate count ；检查防火墙nat工作状态</span><br></pre></td></tr></table></figure>
<p><a href="https://www.sohu.com/a/313842412_120146424#:~:text=%E6%80%9D%E7%A7%91%20%28Cisco%29%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%201%20router%3Eenable%20%E8%BF%9B%E5%85%A5%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%202%20router%23config%20terminal,0%204%20%E8%BF%9B%E5%85%A5%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF%208%20router%20%28config-line%29%23login%20%E8%A6%81%E6%B1%82%E5%8F%A3%E4%BB%A4%E9%AA%8C%E8%AF%81%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">Cisco常用命令</a><br>
<a href="https://zhuanlan.zhihu.com/p/385018975#:~:text=CISCO%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A1%E6%A3%80%E5%91%BD%E4%BB%A4%201%E3%80%81show%20interface%20stats,%EF%BC%9B%E6%9F%A5%E7%9C%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%BD%93%E5%89%8D%E6%8E%A5%E5%8F%A3%E6%B5%81%E9%87%8F%202%E3%80%81show%20running-config%20%EF%BC%9B%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE">Cisco常用命令1</a></p>
<h3 id="常用的华为网络命令">常用的华为网络命令</h3>
<h4 id="用户视图">用户视图</h4>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">display ip interface brief</td>
<td style="text-align:center">查看端口IP信息</td>
</tr>
<tr>
<td style="text-align:center">display arp</td>
<td style="text-align:center">查看ARP表</td>
</tr>
<tr>
<td style="text-align:center">rebot</td>
<td style="text-align:center">重启设备</td>
</tr>
<tr>
<td style="text-align:center">reset saved-configuration</td>
<td style="text-align:center">重置设备配置</td>
</tr>
<tr>
<td style="text-align:center">system-view</td>
<td style="text-align:center">进入系统视图</td>
</tr>
<tr>
<td style="text-align:center">save</td>
<td style="text-align:center">保存设备信息</td>
</tr>
<tr>
<td style="text-align:center">2. 系统视图</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">aaa</td>
<td style="text-align:center">进入3A视图</td>
</tr>
<tr>
<td style="text-align:center">acl [数字]</td>
<td style="text-align:center">创建并进入acl规则视图，acl数字从2000开始为基础的规则，从3000开始为扩展规则</td>
</tr>
<tr>
<td style="text-align:center">capwap source interface vlanif [VLAN编号]</td>
<td style="text-align:center">建立capwap隧道</td>
</tr>
<tr>
<td style="text-align:center">clear configuration interface [接口]</td>
<td style="text-align:center">清除指定接口上的配置</td>
</tr>
<tr>
<td style="text-align:center">dhcp enable</td>
<td style="text-align:center">开启设备的DHCP（动态主机配置协议）功能</td>
</tr>
<tr>
<td style="text-align:center">dhcp select global</td>
<td style="text-align:center">开启基于地址池分配IP的功能</td>
</tr>
<tr>
<td style="text-align:center">dhcp server excluded-ip-address [IP地址]</td>
<td style="text-align:center">将指定的IP地址排除出IP地址池之外</td>
</tr>
<tr>
<td style="text-align:center">dhcp snooping enable</td>
<td style="text-align:center">开启DHCP的snooping功能</td>
</tr>
<tr>
<td style="text-align:center">dhcp snooping enable vlan [数字]</td>
<td style="text-align:center">在指定的VLAN中开启DHCP功能，属于该VLAN的DHCP功能将被允许</td>
</tr>
<tr>
<td style="text-align:center">dhcp relay server-ip [IP地址]</td>
<td style="text-align:center">设置DHCP服务器的端口地址</td>
</tr>
<tr>
<td style="text-align:center">display acl all</td>
<td style="text-align:center">显示当前所有的ACL规则</td>
</tr>
<tr>
<td style="text-align:center">display ap all</td>
<td style="text-align:center">查看所有AP设备的上线情况</td>
</tr>
<tr>
<td style="text-align:center">display bridge mac-address</td>
<td style="text-align:center">显示路由交换机的MAC地址</td>
</tr>
<tr>
<td style="text-align:center">display current-configuration interface [端口信息]</td>
<td style="text-align:center">显示防火墙的指定端口配置信息</td>
</tr>
<tr>
<td style="text-align:center">display firewall session aging-time</td>
<td style="text-align:center">查看防火墙会话表的老化时间</td>
</tr>
<tr>
<td style="text-align:center">display firewall session table</td>
<td style="text-align:center">查看防火墙会话表简要信息</td>
</tr>
<tr>
<td style="text-align:center">display firewall session table verbose</td>
<td style="text-align:center">查看防火墙会话表详细信息</td>
</tr>
<tr>
<td style="text-align:center">display hrp state</td>
<td style="text-align:center">显示hrp状态信息</td>
</tr>
<tr>
<td style="text-align:center">display ip interface brief</td>
<td style="text-align:center">显示防火墙接口配置信息</td>
</tr>
<tr>
<td style="text-align:center">display ip routing-table</td>
<td style="text-align:center">显示路由表</td>
</tr>
<tr>
<td style="text-align:center">display mac-address</td>
<td style="text-align:center">查看MAC表</td>
</tr>
<tr>
<td style="text-align:center">display mac-address aging-time</td>
<td style="text-align:center">查看MAC表老化时间</td>
</tr>
<tr>
<td style="text-align:center">display saved-configuration</td>
<td style="text-align:center">查看当前已保存配置</td>
</tr>
<tr>
<td style="text-align:center">display this</td>
<td style="text-align:center">显示当前配置</td>
</tr>
<tr>
<td style="text-align:center">display vrrp</td>
<td style="text-align:center">显示vrrp信息</td>
</tr>
<tr>
<td style="text-align:center">display vrrp brief</td>
<td style="text-align:center">查看当前vrrp备份组信息</td>
</tr>
<tr>
<td style="text-align:center">firewall zone trust</td>
<td style="text-align:center">进入防火墙的信任区视图</td>
</tr>
<tr>
<td style="text-align:center">firewall zone untrust</td>
<td style="text-align:center">进入防火墙的非信任区视图</td>
</tr>
<tr>
<td style="text-align:center">hrp enable</td>
<td style="text-align:center">开启HRP备份功能</td>
</tr>
<tr>
<td style="text-align:center">hrp interface [接口名] [端口] remote [IP地址]</td>
<td style="text-align:center">为vrrp设备指定心跳口，IP地址为端口的地址</td>
</tr>
<tr>
<td style="text-align:center">interface [接口名] [端口]</td>
<td style="text-align:center">进入某接口的视图</td>
</tr>
<tr>
<td style="text-align:center">interface vlanif [网段]</td>
<td style="text-align:center">进入指定VLAN的SVI虚拟接口</td>
</tr>
<tr>
<td style="text-align:center">ip pool [名称]</td>
<td style="text-align:center">创建并进入IP地址池</td>
</tr>
<tr>
<td style="text-align:center">ip route-static [下一跳网段] [掩码] [下一跳IP地址]</td>
<td style="text-align:center">设置静态路由，IP地址为下一跳路由器端口地址</td>
</tr>
<tr>
<td style="text-align:center">ip route-static 0.0.0.0 0 [下一跳IP地址]</td>
<td style="text-align:center">设置默认路由，IP地址为下一跳路由器端口地址。注意第四个0和第五个0中间是空格不是小数点，第五个0也可以写成0.0.0.0表示完全匹配</td>
</tr>
<tr>
<td style="text-align:center">mac-address aging-time [时间]</td>
<td style="text-align:center">设置MAC地址表老化时间，默认老化时间为300秒</td>
</tr>
<tr>
<td style="text-align:center">mac-address static [MAC地址] [端口]vlan 1</td>
<td style="text-align:center">将MAC地址绑定到指定端口，交换机中所有的接口默认vlan 1</td>
</tr>
<tr>
<td style="text-align:center">port-group group-member [端口1] to [端口2]</td>
<td style="text-align:center">将多个端口创建成临时的端口组，并进入该端口组</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">返回上一级视图，即用户视图</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">返回上一级视图，即用户视图</td>
</tr>
<tr>
<td style="text-align:center">rsa local-key-pair create</td>
<td style="text-align:center">创建本地密钥对</td>
</tr>
<tr>
<td style="text-align:center">security-policy</td>
<td style="text-align:center">进入防火墙安全策略</td>
</tr>
<tr>
<td style="text-align:center">stelnet server enable</td>
<td style="text-align:center">开启SSH服务</td>
</tr>
<tr>
<td style="text-align:center">sysname [名称]</td>
<td style="text-align:center">修改设备名称</td>
</tr>
<tr>
<td style="text-align:center">telnet server enable</td>
<td style="text-align:center">开启telnet服务</td>
</tr>
<tr>
<td style="text-align:center">undo info-center enable</td>
<td style="text-align:center">关闭信息中心日志</td>
</tr>
<tr>
<td style="text-align:center">undo mac-address</td>
<td style="text-align:center">清空MAC表</td>
</tr>
<tr>
<td style="text-align:center">user-bind static ip-address [IP地址] mac-address [MAC地址] interface [接口信息] vlan [数字]</td>
<td style="text-align:center">创建用户绑定表，绑定IP、MAC、端口和VLAN</td>
</tr>
<tr>
<td style="text-align:center">user-interface console 0</td>
<td style="text-align:center">进入console接口</td>
</tr>
<tr>
<td style="text-align:center">user-interface vty 0 4</td>
<td style="text-align:center">进入VTY接口，VTY即虚拟终端</td>
</tr>
<tr>
<td style="text-align:center">vlan [网段]</td>
<td style="text-align:center">创建并进入VLAN视图</td>
</tr>
<tr>
<td style="text-align:center">vlan batch [网段1] [网段2] [网段3] …</td>
<td style="text-align:center">创建多个VLAN</td>
</tr>
<tr>
<td style="text-align:center">wlan</td>
<td style="text-align:center">进入wlan视图</td>
</tr>
<tr>
<td style="text-align:center">3. 接口视图</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">action permit</td>
<td style="text-align:center">在安全策略规则视图下，将已设置的规则提交</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">在vrrp视图下，将设备加入到active的VGMP管理组</td>
</tr>
<tr>
<td style="text-align:center">add interface [接口信息]</td>
<td style="text-align:center">在信任区/非信任区视图下，将该接口划入信任区/非信任区</td>
</tr>
<tr>
<td style="text-align:center">ap auth-mode mac-auth</td>
<td style="text-align:center">在wlan视图下，设置AP设备的认证模式为MAC认证</td>
</tr>
<tr>
<td style="text-align:center">ap-id [编号]</td>
<td style="text-align:center">创建并进入指定的AP视图</td>
</tr>
<tr>
<td style="text-align:center">ap-mac [MAC地址]</td>
<td style="text-align:center">在ap视图下，配置ap设备的物理/MAC地址</td>
</tr>
<tr>
<td style="text-align:center">ap-name [名称]</td>
<td style="text-align:center">在ap视图下，设置ap视图的名称</td>
</tr>
<tr>
<td style="text-align:center">ap-group [ap组名称]</td>
<td style="text-align:center">在ap视图下，将当前的ap模板添加到ap组中</td>
</tr>
<tr>
<td style="text-align:center">ap-group name [模板名称]</td>
<td style="text-align:center">在wlan视图下，创建ap组，进入ap组视图</td>
</tr>
<tr>
<td style="text-align:center">authentication-mode aaa</td>
<td style="text-align:center">在VTY接口视图下，设置3A模式</td>
</tr>
<tr>
<td style="text-align:center">authentication-mode password</td>
<td style="text-align:center">在cosole接口下，当指令输入完毕，提示设置本地设备密码</td>
</tr>
<tr>
<td style="text-align:center">bind manager-user [用户名] role system-admin</td>
<td style="text-align:center">在3a视图下，绑定指定用户为系统管理员</td>
</tr>
<tr>
<td style="text-align:center">country-code [国家码]</td>
<td style="text-align:center">在domain视图下，设置国家码，中国的国家码为cn</td>
</tr>
<tr>
<td style="text-align:center">destination-zone [trust                                                                                                                                                                                         untrust]</td>
<td style="text-align:center">在安全策略规则视图下，设置规则的目的为信任区域/非信任区</td>
</tr>
<tr>
<td style="text-align:center">dhcp select relay</td>
<td style="text-align:center">在端口视图下，开启端口的DHCP中继功能</td>
</tr>
<tr>
<td style="text-align:center">dhcp snooping trusted</td>
<td style="text-align:center">在端口视图下，将该接口设置为信任模式</td>
</tr>
<tr>
<td style="text-align:center">display this</td>
<td style="text-align:center">在端口视图下，显示当前配置</td>
</tr>
<tr>
<td style="text-align:center">dns-list [IP地址]</td>
<td style="text-align:center">在IP地址池视图下，设置地址池默认的DNS服务器</td>
</tr>
<tr>
<td style="text-align:center">excluded-ip-address [IP地址a] [IP地址b]</td>
<td style="text-align:center">在IP地址池视图下，将IP地址范围a到b的地址排除在IP地址池外</td>
</tr>
<tr>
<td style="text-align:center">forward-mode [转发方式]</td>
<td style="text-align:center">在vap视图下，转发方式为tunnel表示隧道转发，direct-forward表示直接转发</td>
</tr>
<tr>
<td style="text-align:center">gateway-list [IP地址]</td>
<td style="text-align:center">在IP地址池视图下，设置默认网关地址</td>
</tr>
<tr>
<td style="text-align:center">idle-timeout [分钟] [秒]</td>
<td style="text-align:center">在console0视图下，设置用户连接的超时时长，如果不填参数的话默认的时长为10分钟，如果设置成idle-timeout 0表示经过任何时长用户都不会退出登录。</td>
</tr>
<tr>
<td style="text-align:center">ip address [IP地址] [掩码]</td>
<td style="text-align:center">在接口视图下，设置接口的IP地址</td>
</tr>
<tr>
<td style="text-align:center">level [数字]</td>
<td style="text-align:center">在3a模式的用户视图下，设置用户等级</td>
</tr>
<tr>
<td style="text-align:center">mac-address learning disable action [discard                                                                forward]</td>
<td style="text-align:center">在接口视图下，关闭接口的自动学习功能，若不填写action及后面的参数discard时默认为forward。discard表示不学习也不转发报文，设置为forward时不会自动学习但会转发报文。</td>
</tr>
<tr>
<td style="text-align:center">mac-vlan mac-address [MAC地址]</td>
<td style="text-align:center">在VLAN视图下，将MAC地址与该VLAN进行绑定</td>
</tr>
<tr>
<td style="text-align:center">manager-user [用户名]</td>
<td style="text-align:center">在aaa视图下，创建并进入指定用户视图</td>
</tr>
<tr>
<td style="text-align:center">net work [IP地址] mask [掩码]</td>
<td style="text-align:center">在IP地址池视图下，设置地址池可分配的IP地址范围</td>
</tr>
<tr>
<td style="text-align:center">password</td>
<td style="text-align:center">在3a模式的用户视图下，设置指定用户的密码</td>
</tr>
<tr>
<td style="text-align:center">port default vlan [网段]</td>
<td style="text-align:center">在接口视图下，为接口分配VLAN</td>
</tr>
<tr>
<td style="text-align:center">port hybrid pvid vlan [网段]</td>
<td style="text-align:center">在接口视图下，设置接口的VLAN</td>
</tr>
<tr>
<td style="text-align:center">port hybrid [ tagged                                                                                                                                                                             untagged ] vlan [网段1] [网段2] …</td>
<td style="text-align:center">在端口视图下，设置经过该端口的网段报文将会被添加tag或去除tag</td>
</tr>
<tr>
<td style="text-align:center">port link-type [access                                                                                                                                                                              or                            trunk  or hybrid]</td>
<td style="text-align:center">设置接口的VLAN类型，access类型用于主机和交换机间，trunk类型用于交换机和交换机之间, hybrid是华为交换机特有的接口类型兼容了access和trunk</td>
</tr>
<tr>
<td style="text-align:center">port-security enable</td>
<td style="text-align:center">在接口视图下，开启接口的安全功能</td>
</tr>
<tr>
<td style="text-align:center">port-security mac-address sticky</td>
<td style="text-align:center">在接口视图下，设置安全功能，当第一次学习到MAC地址就会绑定对应的端口</td>
</tr>
<tr>
<td style="text-align:center">port-security max-mac-num [个数]</td>
<td style="text-align:center">在端口视图下，设置端口安全功能的MAC地址最大学习数</td>
</tr>
<tr>
<td style="text-align:center">port-security protect-action [protect                                                                                                             restrict                                                                         shutdown]</td>
<td style="text-align:center">在端口视图下，设置端口安全功能中学习到MAC超过限制或出现静态MAC地址漂移时的保护动作，shutdown为关闭端口可用于泛洪攻击的防御手段。</td>
</tr>
<tr>
<td style="text-align:center">port trunk allow-pass vlan [网段1] [网段2] [网段3] …</td>
<td style="text-align:center">在接口视图下，设置trunk口允许通过的VLAN网段</td>
</tr>
<tr>
<td style="text-align:center">preempt-mode timer delay [时长]</td>
<td style="text-align:center">在vrrp视图下，设置抢占延迟时间，单位为秒</td>
</tr>
<tr>
<td style="text-align:center">priority [优先级]</td>
<td style="text-align:center">在vrrp视图下，设置对应的优先级，不填写优先级时默认100，数字越大优先级越高</td>
</tr>
<tr>
<td style="text-align:center">protocol [inbound</td>
<td style="text-align:center">outbound] [协议类型]    在VTY接口视图下，允许指定协议类型的报文通过，all表示所有协议类型</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">在接口视图下，返回上一级视图，即系统视图</td>
</tr>
<tr>
<td style="text-align:center">regulatory-domain-profile [domain模板名称]</td>
<td style="text-align:center">在ap组视图下，绑定domain模板</td>
</tr>
<tr>
<td style="text-align:center">regulatory-domain-profile name [模板名称]</td>
<td style="text-align:center">在wlan视图下，创建域管理模板，进入domain视图</td>
</tr>
<tr>
<td style="text-align:center">rule name [规则]</td>
<td style="text-align:center">在安全策略视图下，创建并进入安全策略规则视图</td>
</tr>
<tr>
<td style="text-align:center">rule deny ip    在</td>
<td style="text-align:center">acl规则视图下，禁止所有的IP报文通过端口，禁止范围不包括acl规则允许的IP地址。</td>
</tr>
<tr>
<td style="text-align:center">rule deny source [IP地址段] 0.0.0.255</td>
<td style="text-align:center">在acl规则视图下，设置只禁止来自目标IP地址段的报文通过，目标IP地址段末尾为0</td>
</tr>
<tr>
<td style="text-align:center">rule [deny                                                                                                                                        permit] tcp source [IP地址] 0 destination-port eq [协议类型]</td>
<td style="text-align:center">在acl规则视图下，permit表示允许源IP地址可以使用指定的协议服务访问目标IP地址，deny表示拒绝源IP地址使用指定的协议服务访问目标IP地址。eq表示两个等于号，0表示完全匹配。</td>
</tr>
<tr>
<td style="text-align:center">rule [deny                                                                                                                                                             permit] source [IP地址段] 0.0.0.0.255</td>
<td style="text-align:center">在acl规则视图下，permit表示只允许来自目标IP地址段的报文通过，deny表示只禁止来自目标IP地址段的报文通过，目标IP地址段末尾为0</td>
</tr>
<tr>
<td style="text-align:center">security [安全策略] [接入认证方式] pass-phrase [wifi密码] [加密方式]</td>
<td style="text-align:center">在sec视图下，设置wifi的信息，安全策略常用wpa-wpa2，接入认证方式采用psk，加密方式采用aes</td>
</tr>
<tr>
<td style="text-align:center">security-profile [sec模板名称]</td>
<td style="text-align:center">在vap视图下，绑定sec模板</td>
</tr>
<tr>
<td style="text-align:center">security-profile name [模板名称]</td>
<td style="text-align:center">在wlan视图下，创建sec模板，进入sec视图</td>
</tr>
<tr>
<td style="text-align:center">service-manage [协议类型] permit</td>
<td style="text-align:center">在接口视图下，允许指定协议类型的报文通过。如果需要使用网页登录防火墙时，可设置https类型报文通过。如果需要使用telnet登录防火墙时，就允许telnet类型报文通过。all类型表示所有协议</td>
</tr>
<tr>
<td style="text-align:center">service-type [协议类型]</td>
<td style="text-align:center">在3a模式的用户视图下，允许指定协议报文通过</td>
</tr>
<tr>
<td style="text-align:center">source-zone [trust                                                                                                                                                                                           untrust]</td>
<td style="text-align:center">在安全策略规则视图下，设置规则的来源为信任区域/非信任区</td>
</tr>
<tr>
<td style="text-align:center">ssid [wifi名称]</td>
<td style="text-align:center">在ssid视图下，设置wifi的名称</td>
</tr>
<tr>
<td style="text-align:center">ssid-profile [ssid模板名称]</td>
<td style="text-align:center">在vap视图下，绑定ssid模板</td>
</tr>
<tr>
<td style="text-align:center">ssid-profile name [模板名称]</td>
<td style="text-align:center">在wlan视图下，创建模板ssid，进入ssid视图</td>
</tr>
<tr>
<td style="text-align:center">traffic-filter [inbound                                                                                                                                                                    outbound] acl [数字]</td>
<td style="text-align:center">在端口视图下，使用指定的ACL规则，inbound表示应用在进入端口的报文，outbound表示应用在从端口出去的报文</td>
</tr>
<tr>
<td style="text-align:center">user privilege level [数字]</td>
<td style="text-align:center">在VTY接口视图下，设置用户的权限等级</td>
</tr>
<tr>
<td style="text-align:center">vap-profile name [模板名称]</td>
<td style="text-align:center">在wlan视图下，创建vap模板，进入vap视图</td>
</tr>
<tr>
<td style="text-align:center">vap-profile [vap模板名称] wlan [wlan编号] radio [射频参数]</td>
<td style="text-align:center">在ap视图或ap组视图下，绑定vap模板，设置wlan，设置射频参数，参数为0表示2.4G赫兹，参数为1表示5G赫兹</td>
</tr>
<tr>
<td style="text-align:center">virtual-ip [IP地址]</td>
<td style="text-align:center">在vrrp视图下，配置虚拟IP地址</td>
</tr>
<tr>
<td style="text-align:center">&lt;br/                                                                                                                 vrrp vrid [编号]</td>
<td style="text-align:center">在接口视图下，创建并进入指定编号的vrrp备份组，若已存在则直接进入对应的vrrp视图</td>
</tr>
<tr>
<td style="text-align:center">4. 常用查询命令</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">display ip int brief</td>
<td style="text-align:center">查看接口ip地址</td>
</tr>
<tr>
<td style="text-align:center">display interface brief</td>
<td style="text-align:center">查看接口的简要信息</td>
</tr>
<tr>
<td style="text-align:center">display current-configuration</td>
<td style="text-align:center">显示当前配置文件</td>
</tr>
<tr>
<td style="text-align:center">display current-configuration</td>
<td style="text-align:center">关键词（查看关键词的配置）</td>
</tr>
<tr>
<td style="text-align:center">display saved-configuration</td>
<td style="text-align:center">显示保存的配置文件</td>
</tr>
<tr>
<td style="text-align:center">display ip routing-table</td>
<td style="text-align:center">查看路由表</td>
</tr>
<tr>
<td style="text-align:center">display ospf peer</td>
<td style="text-align:center">查看ospf邻居关系</td>
</tr>
<tr>
<td style="text-align:center">display ospf lsdb</td>
<td style="text-align:center">查看转发表</td>
</tr>
<tr>
<td style="text-align:center">display fib</td>
<td style="text-align:center">查看系统当前时间</td>
</tr>
<tr>
<td style="text-align:center">display this</td>
<td style="text-align:center">查看当前模式下的配置，比如在接口上敲这条命令就可以看到当前接口下的信息</td>
</tr>
<tr>
<td style="text-align:center">display vlan</td>
<td style="text-align:center">查看VLAN</td>
</tr>
<tr>
<td style="text-align:center">display arp</td>
<td style="text-align:center">查看ARP表</td>
</tr>
<tr>
<td style="text-align:center">display mac-address</td>
<td style="text-align:center">查看MAC地址表</td>
</tr>
<tr>
<td style="text-align:center">display bridge mac-address</td>
<td style="text-align:center">查看本机MAC地址</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://dreamisland.blog.csdn.net/article/details/116003497?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-4-116003497-blog-121360387.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-4-116003497-blog-121360387.pc_relevant_landingrelevant&amp;utm_relevant_index=9">华为常用命令参考</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><a href="https://blog.csdn.net/weixin_43955429/article/details/89054488">华为常用查询命令参考</a></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="流策略与简化流策略">流策略与简化流策略</h4>
<blockquote>
<p>这两个是Cisco网络所没有的，</p>
</blockquote>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>netTopo</title>
    <url>/2023/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="数据库学习">数据库学习</h2>
<span id="more"></span>
<h3 id="本次项目中使用的数据库为MySQL-本次项目为netTopo">本次项目中使用的数据库为MySQL 本次项目为netTopo</h3>
<blockquote>
<p>数据库配置</p>
<blockquote>
<p>本次项目采用Tomcat服务器，前后端不分离</p>
</blockquote>
<p>项目结构</p>
</blockquote>
  
<p>由图中可以看到 采用的为SMV架构 其中dao是专门进行数据库处理的 为每个表划分单个类进行数据库处理<br>
首先是数据库的基本配置(采用JDBC连接)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = null;</span><br><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/switch_info?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8&amp;useOldAliasMetadataBehavior=true&quot;;</span><br><span class="line">String username = &quot;root&quot;;</span><br><span class="line">String password = &quot;password&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="数据库的查询-根据IP查找其他字段内容">数据库的查询(根据IP查找其他字段内容)</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;FibInfo&gt; queryInfoByIp(String ip)&#123;</span><br><span class="line">    List&lt;FibInfo&gt; result=new ArrayList&lt;&gt;();</span><br><span class="line">    Connection conn =  getConnection();</span><br><span class="line">    try &#123;</span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) conn.prepareStatement</span><br><span class="line">                (&quot;SELECT name,mask,port FROM fib_table where ip = ?;&quot;);</span><br><span class="line">        stmt.setString(1, ip);</span><br><span class="line">        ResultSet rs =  stmt.executeQuery();</span><br><span class="line">        while(rs.next()) &#123;</span><br><span class="line">            String name=rs.getString(&quot;name&quot;);</span><br><span class="line">            String mask=rs.getString(&quot;mask&quot;);</span><br><span class="line">            String port = rs.getString(&quot;port&quot;);</span><br><span class="line">            result.add(new FibInfo(name,ip,mask,port));</span><br><span class="line">        &#125;</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库的增加">数据库的增加</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int addInfoList(List&lt;FibInfo&gt; fibTable)&#123;</span><br><span class="line">    Connection conn = getConnection();</span><br><span class="line">    PreparedStatement stmt= null;</span><br><span class="line">    String sql = &quot;insert into fib_table ( name,ip,mask,port) values(?,?,?,?)&quot;;</span><br><span class="line">    for(FibInfo fibInfo:fibTable)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            stmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">            stmt.setString(1,fibInfo.getName());</span><br><span class="line">            stmt.setString(2,fibInfo.getIp());</span><br><span class="line">            stmt.setString(3,fibInfo.getMask());</span><br><span class="line">            stmt.setString(4,fibInfo.getPort());</span><br><span class="line">            stmt.executeUpdate();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        if(stmt!=null)</span><br><span class="line">            stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库的删除操作">数据库的删除操作</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean delInfo(String ip)&#123;</span><br><span class="line">    String sql=&quot;delete from fib_table where ip=&#x27;&quot; + ip + &quot;&#x27;&quot;;</span><br><span class="line">    return this.execute(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deleteAllInfo()&#123;</span><br><span class="line">    String sql=&quot;truncate table fib_table&quot;;</span><br><span class="line">    this.executedelete(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这两种方式，前者是删除fib_table，后者是清空fib_table的内容</p>
</blockquote>
<p>当使用多线程访问数据库时，可能会产生报错，具体原因是当一个con未释放，新的con就被申请</p>
<blockquote>
<p>方法：给调用数据库的方法加锁synchronized  如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized public static List&lt;Vlanport&gt; getVlanPorts(String switchIp, String routeTableEcho)  &#123;</span><br><span class="line">    List&lt;Vlanport&gt; vlanRes = new ArrayList&lt;&gt;();</span><br><span class="line">    String[] lines = routeTableEcho.split(&quot;\n|\r\n|\r&quot;);</span><br><span class="line">    SqlTest h = new SqlTest();</span><br><span class="line">    con = h.getConnection();</span><br><span class="line">    String device  = h.queryData(&quot;topo_node&quot;,switchIp,&quot;ip&quot;,&quot;name&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>netTopo项目</tag>
      </tags>
  </entry>
  <entry>
    <title>sshensp</title>
    <url>/2023/04/12/sshensp/</url>
    <content><![CDATA[<h2 id="使用java-ssh连接ensp">使用java ssh连接ensp</h2>
<span id="more"></span>
<h3 id="环境搭建">环境搭建</h3>
<p>首先是在ensp搭建拓扑 并使用cloud连接，建议使用loopback</p>
<h4 id="loopback的创建">loopback的创建</h4>
<h5 id="桌面右键此电脑，点击“属性”">桌面右键此电脑，点击“属性”</h5>
<img src="/2023/04/12/sshensp/img.png" class title="img.png">
<h5 id="打开设备管理器">打开设备管理器</h5>
<img src="/2023/04/12/sshensp/1.png" class title="img.png">>
<h5 id="先选择网络适配器，再点击菜单栏”操作“→”添加过时硬件“">先选择网络适配器，再点击菜单栏”操作“→”添加过时硬件“</h5>
<img src="/2023/04/12/sshensp/2.png" class title="img.png">
<h5 id="点击下一步">点击下一步</h5>
<img src="/2023/04/12/sshensp/3.png" class title="img.png">
<h5 id="选择“安装我手动从列表选择的硬件（高级）”，然后下一步">选择“安装我手动从列表选择的硬件（高级）”，然后下一步</h5>
<img src="/2023/04/12/sshensp/4.png" class title="img.png">
<h5 id="选择添加类型为”网络适配器“，然后下一步">选择添加类型为”网络适配器“，然后下一步</h5>
<img src="/2023/04/12/sshensp/5.png" class title="img.png">
<h5 id="选择厂商为“Microsoft”，型号为“Microsoft-KM-TEST环回适配器”，然后下一步">选择厂商为“Microsoft”，型号为“Microsoft KM-TEST环回适配器”，然后下一步</h5>
<img src="/2023/04/12/sshensp/6.png" class title="img.png">
<h5 id="等待安装完成即可">等待安装完成即可</h5>
<h5 id="安装完成后，打开”网络和Internet“，点击高级网络设置">安装完成后，打开”网络和Internet“，点击高级网络设置</h5>
<img src="/2023/04/12/sshensp/7.png" class title="img.png">
<h5 id="点击更多网络适配器选项">点击更多网络适配器选项</h5>
<img src="/2023/04/12/sshensp/8.png" class title="img.png">
<h5 id="可以看到已经存在我们添加的网络适配器，右键点击属性">可以看到已经存在我们添加的网络适配器，右键点击属性</h5>
<img src="/2023/04/12/sshensp/9.png" class title="img.png">
<h5 id="点击Internet协议版本4">点击Internet协议版本4</h5>
<img src="/2023/04/12/sshensp/10.png" class title="img.png">
<h5 id="配置相应的IP信息即可">配置相应的IP信息即可</h5>
<h4 id="完成loopback的创建后，然后下一步是在ensp添加该loopback">完成loopback的创建后，然后下一步是在ensp添加该loopback</h4>
<h5 id="拖拽cloud到拓扑中">拖拽cloud到拓扑中</h5>
<blockquote></blockquote>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>java开发-前端</title>
    <url>/2023/04/14/java%E5%BC%80%E5%8F%91-%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="Java开发-前端">Java开发-前端</h2>
<span id="more"></span>
<h3 id="滚动条的添加">滚动条的添加</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">style = <span class="string">&quot;overflow-y: auto;overflow-x: auto; width: 100%;height: 800px;&quot;</span></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">style= <span class="string">&quot;overflow:scroll; width:400px; height:400px;&quot;</span></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line">style=<span class="string">&quot;position:absolute; height:400px; overflow:auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//竖直滚动条</span></span><br><span class="line">style=<span class="string">&quot;overflow-y:auto&quot;</span></span><br><span class="line"><span class="comment">//水平滚动条</span></span><br><span class="line">style=<span class="string">&quot;overflow-x:auto&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java命名</title>
    <url>/2023/04/15/java%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<h2 id="Java命名">Java命名</h2>
<span id="more"></span>
<h3 id="包命名规范">包命名规范</h3>
<blockquote>
<p>一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.cloud;</span><br><span class="line">package org.springframework.boot.util;</span><br><span class="line">package org.hibernate.action;</span><br><span class="line">package org.hibernate.cfg;</span><br><span class="line">package com.alibaba.druid;</span><br><span class="line">package com.alibaba.druid.filter;</span><br><span class="line">package com.alibaba.nacos.client.config;</span><br><span class="line">package com.ramostear.blog.web;</span><br></pre></td></tr></table></figure>
<h3 id="类命名规范">类命名规范</h3>
<blockquote>
<p>类(Class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDTO&#123;&#125;</span><br><span class="line">class EmployeeService&#123;&#125;</span><br><span class="line">class StudentDAO&#123;&#125;</span><br><span class="line">class OrderItemEntity&#123;&#125;</span><br><span class="line">public class UserServiceImpl&#123;&#125;</span><br><span class="line">public class OrderItemController&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口命名规范">接口命名规范</h3>
<blockquote>
<p>接口(Interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)</p>
<p>所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Closeable&#123;&#125;</span><br><span class="line">public interface Cloneable&#123;&#125;</span><br><span class="line">public interface Runnable&#123;&#125;</span><br><span class="line">public interface Comparable&lt;T&gt;&#123;&#125;</span><br><span class="line">public interface CompletionService&lt;V&gt;&#123;&#125;</span><br><span class="line">public interface Iterable&lt;T&gt;&#123;&#125;</span><br><span class="line">public interface EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常类命名规范">异常类命名规范</h3>
<blockquote>
<p>异常类(Exception Class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“Exception”作为其后缀。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FileNotFoundException&#123;&#125;</span><br><span class="line">public class UserAlreadyExistException&#123;&#125;</span><br><span class="line">public class TransactionException&#123;&#125;</span><br><span class="line">public class ClassNotFoundException&#123;&#125;</span><br><span class="line">public class IllegalArgumentException&#123;&#125;</span><br><span class="line">public class IndexOutOfBoundsException&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>系统异常，这一类异常类的命名使用“Error”作为其后缀，以区分Exception(编码，环境，操作等异常)。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class VirtualMachineError&#123;&#125;</span><br><span class="line">public class StackOverflowError&#123;&#125;</span><br><span class="line">public class OutOfMemoryError&#123;&#125;</span><br><span class="line">public class IllegalAccessError&#123;&#125;</span><br><span class="line">public class NoClassDefFoundError&#123;&#125;</span><br><span class="line">public class NoSuchFieldError&#123;&#125;</span><br><span class="line">public class NoSuchMethodError&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法命名规范">方法命名规范</h3>
<h4 id="表述获取">表述获取</h4>
<blockquote>
<p>如果一个方法用于获取某个值，通常使用“get”作为其前缀</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getUserIds</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getOne</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表述查询">表述查询</h4>
<blockquote>
<p>如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">findOne</span><span class="params">(Integer id)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">queryOrders</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表述条件">表述条件</h4>
<blockquote>
<p>如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">findByUsername</span><span class="params">(String username)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getUserIdsWithState</span><span class="params">(<span class="type">boolean</span> state)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllByUsernameOrderByIdDesc</span><span class="params">(String username)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表述设置">表述设置</h4>
<blockquote>
<p>如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">insert</span><span class="params">(User user)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAll</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表述设置-2">表述设置</h4>
<blockquote>
<p>如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(Boolean)，则该方法应该使用“is”或”has”作为前缀；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNotEmpty</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasLength</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Set&lt;Integer&gt; mapToSet(HashMap&lt;String,String&gt; a)&#123;&#125;</span><br><span class="line">public UserDto convertTo(User user)&#123;&#125;</span><br><span class="line">public String toString(Object obj)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量命名规范">变量命名规范</h3>
<blockquote>
<p>变量(Variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String nickName;</span><br><span class="line">private String mobileNumber;</span><br><span class="line">private Long id;</span><br><span class="line">private String username;</span><br><span class="line">private Long orderId;</span><br><span class="line">private Long orderItemId;</span><br></pre></td></tr></table></figure>
<h3 id="常量命名规范">常量命名规范</h3>
<blockquote>
<p>一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String LOGIN_USER_SESSION_KEY = &quot;current_login_user&quot;;</span><br><span class="line">public static final int MAX_AGE_VALUE = 120;</span><br><span class="line">public static final int DEFAULT_PAGE_NO = 1;</span><br><span class="line">public static final long MAX_PAGE_SIZE = 1000;</span><br><span class="line">public static final boolean HAS_LICENSE = false;</span><br><span class="line">public static final boolean IS_CHECKED = false;</span><br></pre></td></tr></table></figure>
<h3 id="其它命名规范">其它命名规范</h3>
<h4 id="数组命名">数组命名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] array = new int[10];</span><br><span class="line">int[] idArray =&#123;1,2,3,4,5&#125;;</span><br><span class="line">String[] nameArray = &#123;&quot;First&quot;,&quot;Yellow&quot;,&quot;Big&quot;&#125;</span><br><span class="line">public List&lt;String&gt; getNameById(Integer[] ids)&#123;&#125;</span><br><span class="line">public List&lt;String&gt; getNameById(Integer...ids)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表述复数或者集合">表述复数或者集合</h4>
<blockquote>
<p>如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection&lt;Order&gt; orders;</span><br><span class="line">int[] values;</span><br><span class="line">List&lt;Item&gt; items;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果表述的是一个Map数据，则应使用“map”作为其后缀</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,User&gt; userMap;</span><br><span class="line">Map&lt;String,List&lt;Object&gt;&gt; listMap;</span><br></pre></td></tr></table></figure>
<h4 id="泛型类">泛型类</h4>
<blockquote>
<p>E表示Element，通常用在集合中；</p>
<p>ID用于表示对象的唯一标识符类型</p>
<p>T表示Type(类型)，通常指代类；</p>
<p>K表示Key(键),通常用于Map中；</p>
<p>V表示Value(值),通常用于Map中，与K结对出现；</p>
<p>N表示Number,通常用于表示数值类型；</p>
<p>?表示不确定的Java类型；</p>
<p>X用于表示异常；</p>
<p>U,S表示任意的类型。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;&#123;&#125;</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;&#123;&#125;</span><br><span class="line">public class ThreadLocal&lt;T&gt;&#123;&#125;</span><br><span class="line">public interface Functor&lt;T,X extends Throwable&gt;&#123;</span><br><span class="line">    T val() throws X;</span><br><span class="line">&#125;</span><br><span class="line">public class Container&lt;K,V&gt;&#123;</span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line">    Container(K key,V value)&#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface BaseRepository&lt;T,ID&gt;&#123;</span><br><span class="line">    T findById(ID id);</span><br><span class="line">    void update(T t);</span><br><span class="line">    List&lt;T&gt; findByIds(ID...ids);</span><br><span class="line">&#125;</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; methodName(Class&lt;T&gt; clz)&#123;</span><br><span class="line">    List&lt;T&gt; dataList = getByClz(clz);</span><br><span class="line">    return dataList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口实现类">接口实现类</h4>
<blockquote>
<p>在通常情况下，建议接口实现类使用“Impl作为后缀”，不建议使用大写的“I”作为接口前缀</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OrderService&#123;&#125;</span><br><span class="line">public class OrderServiceImpl implements OrderService&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试类和测试方法">测试类和测试方法</h4>
<blockquote>
<p>测试类采用被测试业务模块名/被测试接口/被测试类+“Test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserServiceTest&#123;</span><br><span class="line">    public void testFindByUsernameAndPassword()&#123;&#125;</span><br><span class="line">    public void testUsernameExist_notExist()&#123;&#125;</span><br><span class="line">    public void testDeleteById_isOk()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>后端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ACL下发</title>
    <url>/2023/04/20/ACL%E4%B8%8B%E5%8F%91/</url>
    <content><![CDATA[<h2 id="ACL的下发方式">ACL的下发方式</h2>
<span id="more"></span>
<h3 id="华为">华为</h3>
<blockquote>
<p>华为ACL一般是与流策略或简化流策略结合使用，此外其还可以在VTY下使用</p>
</blockquote>
<h4 id="VTY">VTY</h4>
<p>如下图所示</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/1.png" class title="img.png">
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ACC1]sys</span><br><span class="line">[ACC1]user-interface vty 0 4 </span><br><span class="line">[ACC1]acl 2000 inbound</span><br><span class="line"></span><br><span class="line">[ACC1]acl 2000</span><br><span class="line">[ACC1]deny ip 192.168.10.2 0 </span><br></pre></td></tr></table></figure>
<p>该示例是在设备ACC1上配置，限制IP地址为192.168.10.2的主机登录到该设备ACC1</p>
<h2 id="其它">其它</h2>
<h3 id="华为-2">华为</h3>
<h4 id="命令行智能回退功能">命令行智能回退功能</h4>
<blockquote>
<p>每条命令行都有支持的视图，比如vlan命令支持的视图是系统视图。在业务部署过程中，用户可能需要在不同视图下配置命令行，这样操作步骤较多，业务部署效率低。</p>
</blockquote>
<blockquote>
<p>设备支持命令行智能回退功能，即如果命令行在当前视图下无法匹配成功，系统会自动回退到系统视图下，如果可以匹配该命令行，则可以直接下发配置，从而减少了命令行操作步骤。</p>
</blockquote>
<blockquote>
<p>例如，interface命令支持的视图是系统视图，但是若用户正在VLAN视图下执行操作，可以直接在VLAN视图下执行interface命令行进入接口视图。</p>
</blockquote>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] vlan 2</span><br><span class="line">[HUAWEI-vlan2] interface 10ge 1/0/1</span><br><span class="line">[HUAWEI-10GE1/0/1]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果用户要关闭命令行只能回退功能，在用户视图下执行命令undo terminal command forward matched upper-view，关闭命令行智能回退功能</p>
</blockquote>
<h4 id="设置命令级别">设置命令级别</h4>
<p>下图是用户级别和命令级别的对应关系</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/2.png" class title="img.png">
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] command-privilege level 5 view shell save</span><br></pre></td></tr></table></figure>
<p>该示例将save命令的级别设置为5</p>
<h4 id="配置Console用户界面">配置Console用户界面</h4>
<h5 id="配置Console用户界面的物理属性">配置Console用户界面的物理属性</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/3.png" class title="img.png">
<h5 id="配置Console用户界面的终端属性">配置Console用户界面的终端属性</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/4.png" class title="img.png">
<h5 id="配置Console用户界面的用户级别">配置Console用户界面的用户级别</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/5.png" class title="img.png">
<h5 id="配置Console用户界面的AAA验证方式">配置Console用户界面的AAA验证方式</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/6.png" class title="img.png">
<h5 id="配置Console用户界面的Password验证方式">配置Console用户界面的Password验证方式</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/7.png" class title="img.png">
<h4 id="检查配置结果">检查配置结果</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display users [ all ]，查看用户界面的使用信息。</span><br><span class="line">display user-interface console ui-number [ summary ]，查看Console用户界面信息。</span><br><span class="line">display user-interface maximum-vty，查看VTY类型用户界面的最大个数。</span><br><span class="line">display user-interface vty ui-number1 [ summary ]，查看VTY用户界面信息。</span><br><span class="line">display ssh server ip-block all，查看所有认证失败的客户端IP地址。</span><br><span class="line">display ssh server ip-block list，查看因认证失败而被锁定的客户端IP地址。</span><br><span class="line">display vty ip-block list，查看因为认证失败而被阻止的IP地址列表。</span><br><span class="line">display vty ip-block all，查看所有认证失败的IP地址。</span><br><span class="line">display vty mode，查看VTY的工作模式。</span><br></pre></td></tr></table></figure>
<h4 id="配置用户通过Telnet登录设备">配置用户通过Telnet登录设备</h4>
<p>配置流程如下图</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/8.png" class title="img.png">
<p>配置用户通过Telnet登录设备的缺省值</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/9.png" class title="img.png">
<h5 id="配置Telent服务器功能及参数">配置Telent服务器功能及参数</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/10.png" class title="img.png">
<h5 id="配置Telnet登录的用户界面">配置Telnet登录的用户界面</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/11.png" class title="img.png">
<h5 id="配置Telnet类型的本地用户-AAA验证">配置Telnet类型的本地用户(AAA验证)</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/12.png" class title="img.png">
<h5 id="检查配置结果-2">检查配置结果</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display users [ all ]命令，查看用户界面连接情况。</span><br><span class="line">display tcp status命令，查看当前建立的所有TCP连接情况。</span><br><span class="line">display telnet server status命令，查看Telnet服务器的当前连接信息。</span><br><span class="line">display vty ip-block list命令，查看因为认证失败而被阻止的IP地址列表。</span><br><span class="line">display vty ip-block all命令，查看所有认证失败的IP地址。</span><br></pre></td></tr></table></figure>
<h4 id="配置设备作为Telnet客户端登录到其它设备">配置设备作为Telnet客户端登录到其它设备</h4>
<p>配置流程如下图</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/13.png" class title="img.png">
<h5 id="配置Telnet客户端参数">配置Telnet客户端参数</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/14.png" class title="img.png">
<h5 id="使用Telnet命令登录其它设备">使用Telnet命令登录其它设备</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/15.png" class title="img.png">
<p>使用<code>display tcp status</code>命令查看当前建立的所有TCP连接情况</p>
<h5 id="示例1">示例1</h5>
<h6 id="拓扑">拓扑</h6>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/16.png" class title="img.png">
<h6 id="步骤">步骤</h6>
<p>1.在用户视图下执行命令install feature-software WEAKEA安装弱安全算法/协议特性包（WEAKEA）。<br>
2.配置Telnet服务器的管理网口IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] sysname Telnet Server</span><br><span class="line">[Telnet Server] interface meth 0/0/0</span><br><span class="line">[Telnet Server-MEth0/0/0] ip address 10.137.217.177 255.255.255.0</span><br><span class="line">[Telnet Server-MEth0/0/0] quit</span><br></pre></td></tr></table></figure>
<p>3.配置服务器的端口号及使能服务器功能(可选)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Telnet Server] telnet server enable</span><br><span class="line">[Telnet Server] telnet server port 1025</span><br><span class="line">[Telnet Server] telnet server-source -i meth 0/0/0</span><br></pre></td></tr></table></figure>
<p>4.配置VTY用户界面的相关参数(可选)<br>
4.1配置VTY用户界面的最大个数<br>
<code>[Telnet Server] user-interface maximum-vty 8</code><br>
4.2配置允许用户登录设备的主机地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Telnet Server] acl 2001</span><br><span class="line">[Telnet Server-acl4-basic-2001] rule permit source 10.137.217.10 0</span><br><span class="line">[Telnet Server-acl4-basic-2001] rule deny source 10.137.217.20 0</span><br><span class="line">[Telnet Server-acl4-basic-2001] quit</span><br><span class="line">[Telnet Server] user-interface vty 0 7</span><br><span class="line">[Telnet Server-ui-vty0-7] acl 2001 inbound</span><br></pre></td></tr></table></figure>
<p>4.3配置VTY用户界面的终端属性(可选)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Telnet Server-ui-vty0-7] shell</span><br><span class="line">[Telnet Server-ui-vty0-7] idle-timeout 20</span><br><span class="line">[Telnet Server-ui-vty0-7] screen-length 30</span><br><span class="line">[Telnet Server-ui-vty0-7] history-command max-size 20</span><br><span class="line">[Telnet Server-ui-vty0-7] protocol inbound telnet</span><br></pre></td></tr></table></figure>
<p>4.4配置VTY用户界面的用户验证方式(aaa)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Telnet Server-ui-vty0-7] authentication-mode aaa</span><br><span class="line">[Telnet Server-ui-vty0-7] quit</span><br></pre></td></tr></table></figure>
<p>5.配置登录用户的相关信息<br>
5.1配置登陆验证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Telnet Server] aaa</span><br><span class="line">[Telnet Server-aaa] local-user admin1234 password</span><br><span class="line">Please configure the login password (8-128)</span><br><span class="line">It is recommended that the password consist of at least 2 types of characters, i</span><br><span class="line">ncluding lowercase letters, uppercase letters, numerals and special characters. </span><br><span class="line">Please enter password:                                      </span><br><span class="line">Please confirm password:                               </span><br><span class="line">Info: Add a new user.</span><br><span class="line">[Telnet Server-aaa] local-user admin1234 service-type telnet</span><br><span class="line">[Telnet Server-aaa] local-user admin1234 privilege level 3</span><br><span class="line">[Telnet Server-aaa] quit</span><br></pre></td></tr></table></figure>
<h6 id="检查配置结果-3">检查配置结果</h6>
<p>1.进入CMD命令行，执行相关命令<br>
<code>C:\Documents and Settings\Administrator&gt; telnet 10.137.217.177 1025</code><br>
2.输入Enter键后，在登录窗口输入AAA验证方式配置的登录用户名和密码，验证通过后，出现用户试图的命令行提示登录设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username:admin1234</span><br><span class="line">Password:</span><br><span class="line">Info: The max number of VTY users is 8, the number of current VTY users online is 1, and total number of terminal users online is 1.</span><br><span class="line">&lt;Telnet Server&gt;</span><br></pre></td></tr></table></figure>
<h6 id="配置脚本-通过dis-cur命令查看">配置脚本(通过dis cur命令查看)</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">sysname Telnet Server</span><br><span class="line">#</span><br><span class="line">telnet server-source -i MEth0/0/0</span><br><span class="line">telnet server port 1025</span><br><span class="line">#</span><br><span class="line">acl number 2001</span><br><span class="line"> rule 5 permit source 10.137.217.10 0</span><br><span class="line"> rule 10 deny source 10.137.217.20 0 </span><br><span class="line">#</span><br><span class="line">aaa</span><br><span class="line"> local-user admin1234 password irreversible-cipher $1d$g8wLJ`LjL!$CyE(V&#123;3qg5DdU:PM[6=6O$UF-.fQ,Q&#125;&gt;^)OBzgoU$</span><br><span class="line"> local-user admin1234 service-type telnet</span><br><span class="line"> local-user admin1234 privilege level 3</span><br><span class="line">#</span><br><span class="line">interface MEth0/0/0</span><br><span class="line"> ip address 10.137.217.177 255.255.255.0</span><br><span class="line">#</span><br><span class="line">user-interface maximum-vty 8</span><br><span class="line">#</span><br><span class="line">user-interface vty 0 7</span><br><span class="line"> acl 2001 inbound</span><br><span class="line"> authentication-mode aaa</span><br><span class="line"> history-command max-size 20</span><br><span class="line"> idle-timeout 20 0</span><br><span class="line"> screen-length 30</span><br><span class="line">#</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
<h5 id="示例2">示例2</h5>
<h6 id="拓扑-2">拓扑</h6>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/17.png" class title="img.png">
<h6 id="步骤-2">步骤</h6>
<p>1.在用户视图下执行命令install feature-software WEAKEA安装弱安全算法/协议特性包（WEAKEA）。<br>
2.配置Device2的Telnet验证方式和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] sysname Device2</span><br><span class="line">[Device2] user-interface vty 0 4</span><br><span class="line">[Device2-ui-vty0-4] authentication-mode aaa</span><br><span class="line">[Device2-ui-vty0-4] quit</span><br></pre></td></tr></table></figure>
<p>3.配置登录用户的相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Device2] aaa</span><br><span class="line">[Device2-aaa] local-user admin1234 password</span><br><span class="line">Please configure the login password (8-128)</span><br><span class="line">It is recommended that the password consist of at least 2 types of characters, i</span><br><span class="line">ncluding lowercase letters, uppercase letters, numerals and special characters. </span><br><span class="line">Please enter password:                                      </span><br><span class="line">Please confirm password:                               </span><br><span class="line">Info: Add a new user.</span><br><span class="line">[Device2-aaa] local-user admin1234 service-type telnet</span><br><span class="line">[Device2-aaa] local-user admin1234 privilege level 3</span><br><span class="line">[Device2-aaa] quit</span><br></pre></td></tr></table></figure>
<p>4.在Device2上配置ACL规则允许Device1登录(可选)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Device2] acl 2000</span><br><span class="line">[Device2-acl4-basic-2000] rule permit source 10.1.1.1 0</span><br><span class="line">[Device2-acl4-basic-2000] quit</span><br><span class="line">[Device2] user-interface vty 0 4</span><br><span class="line">[Device2-ui-vty0-4] acl 2000 inbound</span><br><span class="line">[Device2-ui-vty0-4] quit</span><br></pre></td></tr></table></figure>
<h6 id="检查配置结果-4">检查配置结果</h6>
<p>完成以上配置后，仅可以从Device1上Telnet登录到Device2，无法从其他设备登录到Device2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] sysname Device1</span><br><span class="line">[Device1] quit</span><br><span class="line">&lt;Device1&gt; telnet 10.2.1.1</span><br><span class="line">Username:admin1234</span><br><span class="line">Password:</span><br><span class="line">Info: The max number of VTY users is 8, the number of current VTY users online is 1, and total number of terminal users online is 1.</span><br><span class="line">&lt;Device2&gt;</span><br></pre></td></tr></table></figure>
<h6 id="配置脚本-通过dis-cur命令查看-2">配置脚本(通过dis cur命令查看)</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">sysname Device2</span><br><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 permit source 10.1.1.1 0</span><br><span class="line">#</span><br><span class="line">aaa</span><br><span class="line"> local-user admin1234 password irreversible-cipher $1d$g8wLJ`LjL!$CyE(V&#123;3qg5DdU:PM[6=6O$UF-.fQ,Q&#125;&gt;^)OBzgoU$</span><br><span class="line"> local-user admin1234 privilege level 3</span><br><span class="line"> local-user admin1234 service-type telnet</span><br><span class="line">#</span><br><span class="line">user-interface vty 0 4</span><br><span class="line"> acl 2000 inbound</span><br><span class="line"> authentication-mode aaa</span><br><span class="line">#</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
<h4 id="配置用户使用STelnet登录设备（相比Telent更安全-使用SSH）">配置用户使用STelnet登录设备（相比Telent更安全 使用SSH）</h4>
<h5 id="缺省配置">缺省配置</h5>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/18.png" class title="img.png">
<h5 id="操作步骤">操作步骤</h5>
<p>1.使能STelnet功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system-view</span><br><span class="line">stelnet [ipv4|ipv6] server enable</span><br></pre></td></tr></table></figure>
<p>2.配置STelnet服务器功能及参数<br>
3.配置SSH用户登录的用户界面<br>
4.配置SSH用户<br>
5.用户通过STelnet登录设备</p>
<h5 id="检查配置结果-5">检查配置结果</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display ssh user-information [ username ]命令，在SSH服务器端查看SSH用户信息。如果不指定SSH用户，则可以查看SSH服务器端所有的SSH用户信息。</span><br><span class="line">display ssh server status命令，查看SSH服务器的全局配置信息。</span><br><span class="line">display ssh server session命令，在SSH服务器端查看与SSH客户端连接的会话信息。</span><br></pre></td></tr></table></figure>
<h4 id="配置用户作为STelnet客户端登录其它设备">配置用户作为STelnet客户端登录其它设备</h4>
<h5 id="操作步骤-2">操作步骤</h5>
<p>1.配置设备首次连接SSH服务器的方式<br>
2.配置SSH客户端参数<br>
3.使用STelnet命令登录其他设备</p>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/19.png" class title="img.png">
<h5 id="检查配置结果-6">检查配置结果</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display ssh server-info命令，在SSH客户端查看所有SSH服务器与公钥之间的对应关系。</span><br><span class="line">display ssh client session命令，查看SSH客户端密钥重协商后在线会话的接收/发送报文数量，接收/发送报文数据量以及STelnet登录时长。</span><br></pre></td></tr></table></figure>
<h5 id="示例1-2">示例1</h5>
<h6 id="拓扑-3">拓扑</h6>
<img src="/2023/04/20/ACL%E4%B8%8B%E5%8F%91/20.png" class title="img.png">
<h6 id="步骤-3">步骤</h6>
<p>1.配置SSH服务器的管理网口IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] sysname SSH Server</span><br><span class="line">[SSH Server] interface meth 0/0/0</span><br><span class="line">[SSH Server-MEth0/0/0] ip address 10.248.103.194 255.255.255.0</span><br><span class="line">[SSH Server-MEth0/0/0] quit</span><br></pre></td></tr></table></figure>
<p>2.在SSH服务器端生成本地密钥对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] rsa local-key-pair create</span><br><span class="line">The key name will be:Host</span><br><span class="line">The range of public key size is (2048, 4096).</span><br><span class="line">NOTE: Key pair generation will take a short while.</span><br><span class="line">Please input the modulus [default = 3072]:</span><br></pre></td></tr></table></figure>
<p>3.配置SSH服务器的VTY的用户界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] user-interface vty 0 4</span><br><span class="line">[SSH Server-ui-vty0-4] authentication-mode aaa</span><br><span class="line">[SSH Server-ui-vty0-4] protocol inbound ssh</span><br><span class="line">[SSH Server-ui-vty0-4] quit</span><br></pre></td></tr></table></figure>
<p>4.在服务器端创建本地用户，并配置用户服务方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] aaa</span><br><span class="line">[SSH Server-aaa] local-user admin123 password</span><br><span class="line">Please configure the login password (8-128)</span><br><span class="line">It is recommended that the password consist of at least 2 types of characters, i</span><br><span class="line">ncluding lowercase letters, uppercase letters, numerals and special characters. </span><br><span class="line">Please enter password:                                      </span><br><span class="line">Please confirm password:                               </span><br><span class="line">Info: Add a new user.</span><br><span class="line">[SSH Server-aaa] local-user admin123 service-type terminal ssh</span><br><span class="line">[SSH Server-aaa] local-user admin123 privilege level 3</span><br><span class="line">[SSH Server-aaa] quit</span><br></pre></td></tr></table></figure>
<p>5.在服务器端创建SSH用户，并配置认证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] ssh user admin123</span><br><span class="line">[SSH Server] ssh user admin123 authentication-type rsa</span><br></pre></td></tr></table></figure>
<p>6.配置SSH服务器的公钥算法、加密算法、密钥交换算法列表、HMAC认证算法和最小密钥长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] ssh server cipher aes128_ctr aes256_ctr aes192_ctr aes128_gcm aes256_gcm</span><br><span class="line">[SSH Server] ssh server hmac sha2_256 sha2_512</span><br><span class="line">[SSH Server] ssh server key-exchange dh_group_exchange_sha256</span><br><span class="line">[SSH Server] ssh server publickey rsa_sha2_256 rsa_sha2_512</span><br><span class="line">[SSH Server] ssh server dh-exchange min-len 3072</span><br></pre></td></tr></table></figure>
<p>7.SSH客户端使用OpenSSH创建RSA密钥对，并将密钥对中的公钥拷贝至SSH服务器。进入Windows的命令行提示符，创建RSA密钥对，并保存到本地id_rsa.pub文件中（以下内容仅为示例）。<br>
<code>C:\Users\User1&gt;ssh-keygen -t rsa</code><br>
8.SSH服务器编辑SSH客户端OpenSSH生成的公钥，并将编辑后的公钥分配给SSH用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] rsa peer-public-key rsa01 encoding-type openssh</span><br><span class="line">[SSH Server-rsa-public-key] public-key-code begin</span><br><span class="line">[SSH Server-rsa-public-key-rsa-key-code] ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCg5Ag490i6ilB7QuCVb35B8RJEh1DIYB88h2p1qjdh7qdMQv8rpJaVAgQWxwzKZO0XdFuz4ReGQzTCSf7Det7Ajicddw3qi+6P8hRqZj6MPdLg/o3RN4aPCfr/LFWCwqJ3gWGHlOC7qqjRk+6pySVoiWcSk5/elBkU7WVk/cSWrt4qFXJV373OCesKcEVeDvAa1Tvx6L3LQroBqUO0EXzDgOthPCmOqiqvS5h3JipzqVsesdSKjeInooCQzSOv5eePpBcFcIvU6wFiLIZ5vnf6YtypgTVzHuje/sh4xM7Iuuon7AYXKHT8NpO9jd9zA/lKaRPXyDtei1O1Bt/5lxnn </span><br><span class="line">[SSH Server-rsa-public-key-rsa-key-code] public-key-code end</span><br><span class="line">[SSH Server-key-code] peer-public-key end</span><br><span class="line">[SSH Server] ssh user admin123 assign rsa-key rsa01</span><br></pre></td></tr></table></figure>
<p>9.使能STelnet功能，并配置用户的服务类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] stelnet server enable</span><br><span class="line">[SSH Server] ssh server-source all-interface</span><br><span class="line">[SSH Server] ssh user admin123 service-type stelnet</span><br></pre></td></tr></table></figure>
<p>10.配置ACL规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSH Server] acl 2000</span><br><span class="line">[SSH Server-acl4-basic-2000] rule permit source 10.248.103.0 8</span><br><span class="line">[SSH Server-acl4-basic-2000] quit</span><br><span class="line">[SSH Server] ssh server acl 2000</span><br></pre></td></tr></table></figure>
<h6 id="检查配置结果-7">检查配置结果</h6>
<p>客户端通过OpenSSH软件登录SSH服务器。进入Windows的命令行提示符，执行OpenSSH命令，通过STelnet方式访问设备<br>
<code>C:\Users\User1&gt;ssh admin123@10.248.103.194</code></p>
<h6 id="配置脚本-通过dis-cur命令查看-3">配置脚本(通过dis cur命令查看)</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">sysname SSH Server</span><br><span class="line">#</span><br><span class="line">acl number 2000</span><br><span class="line"> rule 5 permit source 10.248.103.0 0.0.0.255</span><br><span class="line">#</span><br><span class="line">rsa peer-public-key rsa01 encoding-type openssh</span><br><span class="line"> public-key-code begin</span><br><span class="line">  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCg5Ag490i6ilB7QuCVb35B8RJEh1DIYB88h2p1qjdh7qdMQv8rpJaVAgQWxwzKZO0XdFuz4ReGQzTCSf7Det7Ajicddw3qi+6P8hRqZj6MPdLg/o3RN4aPCfr/LFWCwqJ3gWGHlOC7qqjRk+6pySVoiWcSk5/elBkU7WVk/cSWrt4qFXJV373OCesKcEVeDvAa1Tvx6L3LQroBqUO0EXzDgOthPCmOqiqvS5h3JipzqVsesdSKjeInooCQzSOv5eePpBcFcIvU6wFiLIZ5vnf6YtypgTVzHuje/sh4xM7Iuuon7AYXKHT8NpO9jd9zA/lKaRPXyDtei1O1Bt/5lxnn rsa-key</span><br><span class="line"> public-key-code end</span><br><span class="line"> peer-public-key end</span><br><span class="line">#</span><br><span class="line">aaa</span><br><span class="line"> local-user admin123 password irreversible-cipher $1d$+,JS+))\\2$KVNj(.3`_5x0FCKGv&#125;H&amp;.kUTI`Ff&amp;H*eBqO.ua&gt;)$</span><br><span class="line"> local-user admin123 service-type terminal ssh</span><br><span class="line"> local-user admin123 privilege level 3</span><br><span class="line">#</span><br><span class="line">interface MEth0/0/0</span><br><span class="line"> ip address 10.248.103.194 255.255.255.0</span><br><span class="line">#</span><br><span class="line">stelnet server enable</span><br><span class="line">ssh user admin123</span><br><span class="line">ssh user admin123 authentication-type rsa</span><br><span class="line">ssh user admin123 assign rsa-key rsa01</span><br><span class="line">ssh user admin123 service-type stelnet</span><br><span class="line">ssh server-source all-interface</span><br><span class="line">ssh server acl 2000</span><br><span class="line">#</span><br><span class="line">ssh server cipher aes128_ctr aes256_ctr aes192_ctr aes128_gcm aes256_gcm</span><br><span class="line">ssh server hmac sha2_256 sha2_512</span><br><span class="line">ssh server key-exchange dh_group_exchange_sha256</span><br><span class="line">ssh server publickey rsa_sha2_256 rsa_sha2_512</span><br><span class="line">ssh server dh-exchange min-len 3072</span><br><span class="line">#</span><br><span class="line">user-interface vty 0 4</span><br><span class="line"> authentication-mode aaa</span><br><span class="line"> idle-timeout 120 0</span><br><span class="line"> protocol inbound ssh</span><br><span class="line">#</span><br><span class="line">return</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>数据平面验证</title>
    <url>/2023/04/24/%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="数据平面验证论文阅读">数据平面验证论文阅读</h2>
<span id="more"></span>
<h3 id="Libra">Libra</h3>
<h4 id="重点">重点</h4>
<h5 id="大型网络的定义">大型网络的定义</h5>
<blockquote>
<p>拥有数千台交换机和数百万个转发条目的大型数据中心网络</p>
</blockquote>
<h5 id="满足大型网络中验证的基准">满足大型网络中验证的基准</h5>
<blockquote>
<p>在在几分钟内验证10,000个交换机网络中的所有转发表项和数百万条规则</p>
</blockquote>
<h5 id="扩展和冗余设计原则">扩展和冗余设计原则</h5>
<blockquote>
<p>扩展和冗余设计原则是指在应用程序中构建冗余，以避免出现单一故障点，尽量减少协调，最大程度地减少应用程序服务之间的协调以实现可伸缩性，设计应用程序，使其能够扩大，根据需要添加或删除新实例，通过分区解决限制，使用分区来解决数据库、网络和计算限制等1。这些原则可以帮助设计高性能、高可靠、可扩展的分布式系统2。希望这些信息对你有所帮助。</p>
</blockquote>
<h5 id="除了常见路由错误（循环、黑洞、可达）外的隐性网络错误">除了常见路由错误（循环、黑洞、可达）外的隐性网络错误</h5>
<blockquote>
<p>有些错误只有在进行良性更改时才会显示出来。例如，当一个路由前缀被删除时，它会突然暴露一个不那么具体的前缀的错误</p>
<p>如果删除了10.0.0.0/8的路由前缀，则10.1.1.1/16的地址将无法到达目标，因为它现在被视为10.0.0.0/8的一部分，而该路由前缀已被删除。</p>
</blockquote>
<h5 id="使用MapReduce的原因">使用MapReduce的原因</h5>
<blockquote></blockquote>
<h5 id="数据集">数据集</h5>
<blockquote>
<p>网址：<a href="https://github.com/jvimal/libra-data">https://github.com/jvimal/libra-data</a></p>
</blockquote>
<img src="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E9%AA%8C%E8%AF%81/1.png" class title="img.png">
<h5 id="ToR交换机和Spine交换机">ToR交换机和Spine交换机</h5>
<blockquote>
<p>ToR交换机（Top of Rack Switch）是指将网络接入交换机放在一个服务器机架的上面，每个服务器机架往往有一个或者两个接入交换机。</p>
<p>这种组网的好处是简化布线，从服务器机柜到列头柜只有很少的电缆。ToR交换机既可以是接入层交换机又可以是汇聚层交换机还可以是核心层交换机。</p>
<p>Spine交换机是一种数据中心网络架构中的交换机类型，它通常用于连接ToR交换机和核心交换机</p>
</blockquote>
<h5 id="错误示例">错误示例</h5>
<p>拓扑</p>
<img src="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E9%AA%8C%E8%AF%81/2.png" class title="img.png">
<p>四种拓扑情况</p>
<img src="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E9%AA%8C%E8%AF%81/3.png" class title="img.png">
<blockquote>
<p>分析</p>
<p>环路:图(b)显示了S11转发表中的错误如何导致循环。服务器192.168.0/down掉，S11向上转发数据包，即S21和S22。S11的转发表现在是:192.168.0/24→S21, S22 192.168.1/24→S21, S22网络有两个环路:S21-S11-S21和S22-S11-S22，地址到192.168.0/24的报文永远不会到达目的地。</p>
<p>黑洞:图©显示了如果S22失去其中一个转发表项:192.168.0/24→S11会发生什么。在这种情况下，如果S12将发送到192.168.0/24的数据包分发到S21和S22，到达S22的数据包将被丢弃。</p>
<p>不正确的快照:图(d)显示了一个细微的问题，在验证转发表时可能导致错误的结果。假设S11-S22之间的链路中断。发生了两个事件(如虚线箭头所示图中):e1: S22删除192.168.0/24→S11, e2: S12停止向S22转发报文。由于路由更新的异步性质，这两个事件可以按顺序(e1,e2)或(e2,e1)发生。快照可以捕获一个事件，但不能捕获另一个事件，或者可以检测它们以相反的顺序发生。序列(e1,e2)创建一个临时黑洞，如图©所示，而所需的序列(e2,e1)则不会。为了避免发出不必要的警报(通过检测(e1,e2)，即使它没有发生)，或者完全漏掉一个错误(通过错误地假设(e2,e1)发生了)，Libra必须检测到正确的网络状态。</p>
</blockquote>
<p>不正确的对照对应收敛状态不统一。之后Flash解决了此问题</p>
<h5 id="spine-and-leaf-switches">spine and leaf switches</h5>
<blockquote>
<p>Spine和Leaf交换机是数据中心网络拓扑结构的两个交换层，其中Leaf层由接入交换机组成，这些交换机会对来自服务器的流量进行汇聚并直接连接到Spine或网络核心。而Spine交换机则在全网格拓扑中互连所有Leaf交换机。¹³</p>
</blockquote>
]]></content>
      <tags>
        <tag>数据平面验证</tag>
      </tags>
  </entry>
  <entry>
    <title>锐捷</title>
    <url>/2023/06/05/%E9%94%90%E6%8D%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="锐捷使用">锐捷使用</h2>
<span id="more"></span>
<p>首先eve-ng中配置netword中manage cloud 该cloud ip即为eve-ng的ip</p>
<h3 id="锐捷配置SSH">锐捷配置SSH</h3>
<h4 id="开启SSH">开启SSH</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ruijie#configure terminal</span><br><span class="line">Ruijie(config)#enable service ssh-server</span><br></pre></td></tr></table></figure>
<h4 id="生成加密密钥">生成加密密钥</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ruijie(config)#crypto key generate rsa ------&gt;加密方式有两种：DSA和RSA,可以随意选择</span><br><span class="line">Choose the size of the key modulus in the range of 360 to 2048 for your</span><br><span class="line">Signature Keys. Choosing a key modulus greater than 512 may take</span><br><span class="line">a few minutes.</span><br><span class="line">How many bits in the modulus [1024]: ------&gt;直接敲回车</span><br><span class="line">% Generating 512 bit DSA keys ...[ok]</span><br></pre></td></tr></table></figure>
<h4 id="配置管理IP地址">配置管理IP地址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ruijie(config)#interface vlan 1</span><br><span class="line">Ruijie(config-if)# ip address 192.168.179.135 255.255.255.0  ------&gt;最好配置与cloud同一网段的设备</span><br></pre></td></tr></table></figure>
<h4 id="SSH时仅使用密码登入交换机">SSH时仅使用密码登入交换机</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ruijie(config)#line vty 0 4 ------&gt; 进入SSH密码配置模式，0 4表示允许共5个用户同时SSH登入到交换机</span><br><span class="line">Ruijie(config-line)#login ------&gt;启用需输入密码才能SSH成功</span><br><span class="line">Ruijie(config-line)#password ruijie ------&gt; 将SSH密码设置为ruijie</span><br><span class="line">Ruijie(config-line)#exit ------&gt; 回到全局配置模式</span><br><span class="line">Ruijie(config)#enable password ruijie ------&gt;配置进入特权模式的密码为ruijie</span><br><span class="line">Ruijie(config)#end ------&gt;退出到特权模式</span><br><span class="line">Ruijie#write ------&gt;确认配置正确，保存配置</span><br><span class="line"></span><br><span class="line">注意事项：如果要限制用户使用telnet登录，只能使用SSH登录，则需要调整配置，默认情况下telnet和SSH均可登录。</span><br><span class="line">Ruijie(config)#line vty 0 4</span><br><span class="line">Ruijie(config-line)#transport input ssh</span><br></pre></td></tr></table></figure>
<h4 id="SSH时使用用户名及密码登入交换机">SSH时使用用户名及密码登入交换机</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ruijie(config)#line vty 0 4 ------&gt;进入SSH密码配置模式，0 4表示允许共5个用户同时SSH登入到交换机</span><br><span class="line">Ruijie(config-line)#login local ------&gt;启用SSH时使用本地用户和密码功能</span><br><span class="line">Ruijie(config-line)#exit ------&gt;回到全局配置模式</span><br><span class="line">Ruijie(config)#username admin password ruijie ------&gt;配置远程登入的用户名为admin，密码为ruijie</span><br><span class="line">Ruijie(config)#enable password ruijie ------&gt;配置进入特权模式的密码为ruijie</span><br><span class="line">Ruijie(config)#end ------&gt;退出到特权模式</span><br><span class="line">Ruijie#write ------&gt;确认配置正确，保存配置</span><br></pre></td></tr></table></figure>
<h3 id="IP地址规划">IP地址规划</h3>
<h4 id="地址规划思路">地址规划思路</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级子网范围-&gt;多个二级子网范围-&gt;&#123;用户地址、服务器地址、设备互联地址、网管地址、其他地址&#125;</span><br></pre></td></tr></table></figure>
<p>1.制作规划总表</p>
<img src="/2023/06/05/%E9%94%90%E6%8D%B7%E4%BD%BF%E7%94%A8/img.png" class title="img.png">
<p>2.应用类地址规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原则：</span><br><span class="line">    1.从总表找到所属单位的地址范围，从该范围中细分子网</span><br><span class="line">    2.子网地址段范围应考虑涵盖用户目前需要的数量，以及可能增长量</span><br><span class="line">    3.尽量安全标准的C累子网划分，或者掩码是255.255.255.128这样的子网划分</span><br><span class="line">    4.对于IP资源紧张的子网，规划该子网使用dhcp</span><br><span class="line">    5.要充分考虑为如网关、DHCP等提供网络服务的服务预留IP地址</span><br><span class="line">    6.预留一部分联系的应用类地址空间</span><br><span class="line">办法：</span><br><span class="line">    1.根据业务性质规划，如分为办公、生产业务、管理业务。</span><br><span class="line">    2.按照地理位置规划，在某楼、某楼层或者某房间内的用户使用一个子网内的IP地址</span><br></pre></td></tr></table></figure>
<p>3.设备互联地址规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原则：</span><br><span class="line">    1.对于广播型、点到多点网络，如以太网、设备互联地址分配使用掩码是255.255.255.240这样的子网</span><br><span class="line">    2.对于点到点的网络，设备互联地址分配使用掩码是255.255.255.252这样的子网</span><br><span class="line">    3.预留一部分连续的设备互联地址空间</span><br></pre></td></tr></table></figure>
<p>4.设备网管地址规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">划分：</span><br><span class="line">    1.将设备网管地址与应用类网段隔离开，如用户网段为10.16.x.x/24，则可以将设备管理地址规划为</span><br><span class="line">      192.168.x.x/24或10.x.x.x/24等</span><br><span class="line">    2.使用32位主机地址，这种情况在部署了OSPF网络中比较常见。如路由器A的网络管理地址是10.60.6.19/32</span><br><span class="line">    3.和应用类地址共用一个子网，如交换机A是信息学院5号楼办公楼子网10.8.10.0/24的接入交换机，用</span><br><span class="line">      户地址使用10.8.10.10-10.8.10.240.交换机A的网管地址是10.8.10.252</span><br><span class="line">    4.预留一部分连续的设备网关地址空间</span><br></pre></td></tr></table></figure>
<p>5.外网地址规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">划分：</span><br><span class="line">    1.接入路由器或防火墙等设备的外出接口地址，与局端子网一直</span><br><span class="line">    2.用户访问外部网络需要的公网地址池，内部访问外网时会使用NAT等技术，以NAT为例，就需要为内部用户提供一个</span><br><span class="line">      公网地址或几个公网地址组成的地址池</span><br><span class="line">    3.对外提供服务的服务器需要使用公网地址，比如会有WWW、FTP、MAIL等服务器使用内部私有地址需要转换成公网地址，</span><br><span class="line">      或者把这些服务器置于DMZ区直接使用公网地址等。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>404 Not Found：该页面无法显示</title>
    <url>//404.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
